<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, interactive-widget=resizes-content">
    <title>Praxis Chat</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #18453B;
            --primary-light: #0B9A6D;
            --primary-dark: #18453B;
            --background: #f9f9f9;
            --text: #333333;
            --light-text: #666666;
            --user-message-bg: #e8f5e9;
            --assistant-message-bg: #ffffff;
            --border: #d0d0d0;
            --shadow: rgba(0, 0, 0, 0.05);
            
            /* Unified spacing variables */
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 0.75rem;
            --spacing-lg: 1.25rem;
            --spacing-xl: 1.5rem;
            
            /* Unified border radius variables */
            --radius-small: 8px;
            --radius-medium: 12px;
            --radius-large: 16px;
            --radius-round: 50%;
            /* Unified size variables - both icons MUST use these */
            --icon-size: 32px;
            --icon-size-mobile: 28px;
            --icon-font-size: 18px;
            --icon-font-size-mobile: 16px;
        }

        [data-theme="dark"] {
            --primary: #18453B;
            --primary-light: #0B9A6D;
            --primary-dark: #0B9A6D;
            --background: #121212;
            --text: #e0e0e0;
            --light-text: #b0b0b0;
            --user-message-bg: #18453B;
            --assistant-message-bg: #1e1e1e;
            --border: #333333;
            --shadow: rgba(0, 0, 0, 0.3);
            --input-bg: #1e1e1e;
            --input-text: #e0e0e0;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body, html {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            height: 100%;
            background-color: var(--background);
            color: var(--text);
            line-height: 1.6;
            margin: 0;
            padding: 0;
        }

        .app-container {
            display: grid;
            grid-template-rows: auto auto 1fr auto;
            height: 100vh;
            height: 100dvh;
            max-width: 900px;
            margin: 0 auto;
            padding: 0 60px;
            overflow: hidden;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0 5px 0;
            background-color: var(--background);
            z-index: 10;
        }

        .logo {
            font-size: 24px;
            font-weight: 600;
            color: var(--primary-dark);
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }

        .logo-icon {
            width: var(--icon-size);
            height: var(--icon-size);
            min-width: var(--icon-size);
            min-height: var(--icon-size);
            max-width: var(--icon-size);
            max-height: var(--icon-size);
            background-color: var(--primary);
            border-radius: var(--radius-small);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: var(--icon-font-size);
            flex-shrink: 0;
            flex-grow: 0;
        }
        
        .logo-separator {
            color: var(--border);
            font-weight: 300;
            margin: 0 10px;
        }
        
        .system-prompt-header {
            font-size: 14px;
            font-weight: 400;
            color: var(--light-text);
            font-style: italic;
            cursor: text;
            padding: 4px 8px 4px 0;
            border-radius: var(--radius-small);
            transition: background-color 0.2s, max-width 0.2s;
            outline: none;
            flex: 1;
            max-width: 600px;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            line-clamp: 2;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-height: 1.4;
        }
        
        .system-prompt-header:hover {
            background-color: rgba(0, 0, 0, 0.02);
            max-width: 800px;
        }
        
        .system-prompt-header:focus {
            background-color: rgba(0, 0, 0, 0.03);
            box-shadow: 0 0 0 1px var(--border);
            white-space: pre-wrap;
            overflow: visible;
            max-width: 800px;
            line-clamp: unset;
            -webkit-line-clamp: unset;
            display: block;
        }
        
        [data-theme="dark"] .system-prompt-header:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        [data-theme="dark"] .system-prompt-header:focus {
            background-color: rgba(255, 255, 255, 0.08);
        }

        .settings-button {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--light-text);
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 8px 12px;
            border-radius: var(--radius-small);
            transition: background-color 0.2s;
        }

        .settings-button:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        [data-theme="dark"] .settings-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .theme-toggle-button {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--light-text);
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 8px 12px;
            border-radius: var(--radius-small);
            transition: background-color 0.2s;
            margin-right: 8px;
        }

        .theme-toggle-button:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        [data-theme="dark"] .theme-toggle-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            padding: 20px;
            overflow-y: auto;
        }

        .settings-modal.open {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--background);
            padding: 30px;
            border-radius: var(--radius-small);
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            border: 1px solid var(--border);
            color: var(--text);
            margin: auto;
            position: relative;
        }

        [data-theme="dark"] .modal-content {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text);
        }

        .close-button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 20px;
            color: var(--light-text);
        }

        .close-button:hover {
            color: var(--text);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 14px;
            color: var(--text);
        }
        
        /* Style checkbox labels differently */
        .form-group label input[type="checkbox"] {
            width: auto;
            margin: 0;
            margin-right: 10px;
            cursor: pointer;
            vertical-align: middle;
        }

        .form-group input:not([type="checkbox"]) {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius-small);
            font-size: 14px;
            background-color: var(--input-bg, var(--assistant-message-bg));
            color: var(--input-text, #333333);
        }

        .form-group input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .save-button, .reset-button {
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: var(--radius-small);
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .save-button {
            background-color: var(--primary);
        }

        .save-button:hover {
            background-color: var(--primary-dark);
        }
        
        .reset-button {
            background-color: #d32f2f;
        }
        
        .reset-button:hover {
            background-color: #b71c1c;
        }
        
        .save-confirmation {
            display: none;
            margin-top: 15px;
            padding: 12px;
            background-color: var(--primary-light);
            color: white;
            border-radius: var(--radius-small);
            text-align: center;
            font-size: 14px;
            font-weight: 500;
            animation: fadeIn 0.3s ease-in;
        }
        
        .save-confirmation.show {
            display: block;
        }

        .chat-container {
            overflow-y: auto;
            padding: var(--spacing-md) var(--spacing-lg) 0 var(--spacing-lg);
            display: flex;
            flex-direction: column;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }

        .message {
            margin-bottom: var(--spacing-md);  /* Reduced from --spacing-lg to --spacing-md */
            max-width: 75%;
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--radius-medium);
            box-shadow: 0 1px 2px var(--shadow);
            position: relative;
            animation: fadeIn 0.3s forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.user {
            align-self: flex-end;
            background-color: var(--user-message-bg);
        }

        .message.assistant {
            align-self: flex-start;
            background-color: var(--assistant-message-bg);
            border: 1px solid var(--border);
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
            font-size: 14px;
            font-weight: 600;
        }
        
        .header-name {
            font-weight: 600;
        }
        
        .thinking-status {
            font-weight: normal;
            color: var(--light-text);
            font-style: italic;
        }
        
        .error-header {
            color: #cc0000;
            font-weight: 600;
        }
        
        [data-theme="dark"] .error-header {
            color: #ff6666;
        }
        
        /* Light theme header colors */
        .message.user .message-header {
            color: #1a5a1a;
        }
        
        .message.assistant .message-header {
            color: #333333;
        }
        
        /* Dark theme header colors */
        [data-theme="dark"] .message.user .message-header {
            color: #a8d5a8;
        }
        
        [data-theme="dark"] .message.assistant .message-header {
            color: #b0b0b0;
        }

        .message-content {
            word-wrap: break-word;
            white-space: pre-wrap;
        }
        
        /* Light theme message text colors */
        .message.user .message-content {
            color: #1a1a1a;
        }
        
        .message.assistant .message-content {
            color: #333333;
        }
        
        /* Dark theme message text colors */
        [data-theme="dark"] .message.user .message-content {
            color: #ffffff;
        }
        
        [data-theme="dark"] .message.assistant .message-content {
            color: #e0e0e0;
        }

        .reroll-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--background);
            border: 1px solid var(--border);
            border-radius: var(--radius-small);
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
            color: var(--light-text);
            opacity: 0;
            transition: opacity 0.2s, background-color 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .reroll-button:hover {
            background-color: var(--user-message-bg);
            color: var(--text);
        }

        .message.assistant:last-of-type:hover .reroll-button {
            opacity: 1;
        }

        .assistant .message-content {
            line-height: 1.7;
        }

        .dots {
            display: inline-flex;
            gap: 4px;
            margin-left: 4px;
        }

        .dot {
            width: 8px;
            height: 8px;
            border-radius: var(--radius-round);
            background-color: var(--primary);
            opacity: 0.7;
        }

        .dot:nth-child(1) { animation: bounce 1.2s infinite 0s; }
        .dot:nth-child(2) { animation: bounce 1.2s infinite 0.2s; }
        .dot:nth-child(3) { animation: bounce 1.2s infinite 0.4s; }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }

        .input-container {
            display: flex;
            padding: 0 0 var(--spacing-xl) 0;
            padding-bottom: calc(var(--spacing-xl) + env(safe-area-inset-bottom));
            background-color: var(--background);
            z-index: 10;
        }
        
        .input-container.with-messages {
            padding-top: var(--spacing-lg);
            border-top: 1px solid var(--border);
            margin-top: 0;
        }
        
        /* When messages exist, the last message should have bottom spacing equal to the input's top spacing */
        .message:last-child {
            margin-bottom: var(--spacing-lg);
        }

        .message-input {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius-small);
            font-size: 16px;
            resize: none;
            min-height: 44px;
            max-height: 200px;
            overflow-y: hidden;
            transition: border-color 0.2s;
            font-family: inherit;
            background-color: var(--input-bg, var(--background));
            color: var(--input-text, var(--text));
            line-height: 1.5;
        }

        .message-input:focus {
            outline: none;
            border-color: var(--primary);
        }


        /* Helper classes */
        .hidden {
            display: none;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .app-container {
                padding: 0 20px;
            }
            
            .header {
                padding: 10px 0;
            }
            
            .logo {
                font-size: 18px;
                gap: 8px;
            }
            
            /* Hide "Chat" text and separator on mobile to give more space to system prompt */
            .logo-text,
            .logo-separator {
                display: none;
            }
            
            /* Dynamic tab scaling on mobile to prevent overflow */
            .tab-nav {
                padding: 5px 10px 10px 10px;
            }
            
            .tab-buttons {
                gap: 6px;
                max-width: calc(100% - 120px); /* Reserve space for status */
            }
            
            .tab-button {
                padding: 8px 10px 8px 10px;  /* Explicit left/right padding for even reduction */
                font-size: 13px;              /* Slightly smaller text */
            }
            
            /* Ultra-compact mode for very small screens */
            @media (max-width: 360px) {
                .tab-buttons {
                    gap: 4px;
                    max-width: calc(100% - 100px);
                }
                
                .tab-button {
                    padding: 7px 8px 7px 8px;  /* Explicit even padding */
                    font-size: 12px;
                    letter-spacing: -0.3px;    /* Slight compression */
                }
                
                .terminal-status {
                    font-size: 10px;
                    gap: 4px;
                    padding: 7px 8px 7px 8px; /* Match compressed mobile tab button padding */
                }
                
                .status-indicator {
                    width: 6px;
                    height: 6px;
                }
            }
            
            .logo-icon {
                width: var(--icon-size-mobile);
                height: var(--icon-size-mobile);
                font-size: var(--icon-font-size-mobile);
            }
            
            .system-prompt-header {
                font-size: 11px;
                max-width: none;
                flex: 1;
                line-clamp: 2;
                -webkit-line-clamp: 2;
                line-height: 1.3;
                margin-right: 10px;
            }
            
            .system-prompt-header:focus {
                max-width: none;
                line-clamp: unset;
                -webkit-line-clamp: unset;
                font-size: 12px;
            }

            .message {
                max-width: 85%;
            }
            
            /* Terminal/Dashboard mobile adjustments */
            .terminal-container {
                flex: 1;
                background-color: var(--background);
                color: #d4d4d4;
                font-family: 'Cascadia Code', 'Fira Code', 'Monaco', 'Courier New', monospace;
                font-size: 10px;
                line-height: 1.0;
                padding: 10px;
                overflow: hidden; /* Changed from 'auto' to 'visible' */
                white-space: pre;
                position: relative;
                min-height: 100%; /* Ensure it fills available space */
            }
            
            .dashboard-frame {
                background-color: #1e1e1e;
                color: #d4d4d4;
                padding: 8px;
                border-radius: var(--radius-small);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
                display: inline-block;
                font-family: monospace;
                font-size: 10px;
                line-height: 1.0;
                width: max-content; /* Ensure frame expands to content */
                min-width: 100%; /* But at least fill the container */
            }
            
            .dashboard-line {
                font-size: inherit;
                white-space: nowrap;
            }
            
            /* Ensure tab content uses full height on mobile */
            .tab-content.active {
                min-height: calc(100vh - 120px);
            }

        }
        
        /* When input is focused, add some visual hints */
        .message-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        /* Tab navigation styles */
        .tab-nav {
            display: flex;
            gap: 10px;
            padding: 5px 20px 10px 20px;
            border-bottom: 1px solid var(--border);
            background-color: var(--background);
            position: relative;
            justify-content: space-between;
            align-items: center;
        }
        
        .tab-buttons {
            display: flex;
            gap: 10px;
            min-width: 0;  /* Allow shrinking */
        }
        
        .tab-button {
            padding: 8px 16px;
            background: none;
            border: none;
            color: var(--light-text);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            border-radius: var(--radius-small);
            transition: all 0.2s;
            position: relative;
            white-space: nowrap;
            flex: 0 1 auto;  /* Allow shrinking width if needed */
            min-width: 0;
            display: flex;
            align-items: center;
            justify-content: center; /* Center text content within compressed button */
        }
        
        .tab-button:hover {
            background-color: rgba(0, 0, 0, 0.05);
            color: var(--text);
        }
        
        [data-theme="dark"] .tab-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .tab-button.active {
            color: var(--primary-dark);
            background-color: var(--user-message-bg);
        }
        
        .tab-button.active::after {
            content: '';
            position: absolute;
            bottom: -11px;
            left: 0;
            right: 0;
            height: 2px;
            background-color: var(--primary);
        }
        
        .tab-content {
            display: none;
            height: 100%;
            overflow: hidden;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
            overflow-y: auto; /* Allow vertical scrolling on the tab itself */
        }
        
        /* Specific fix for terminal tab content */
        #terminal-content {
            overflow-y: auto; /* Allow scrolling */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }

        /* Terminal styles */
        .terminal-container {
            flex: 1;
            background-color: var(--background);  /* Match page background */
            color: #d4d4d4;
            font-family: 'Cascadia Code', 'Fira Code', 'Monaco', 'Courier New', monospace;
            font-size: 10px;
            line-height: 1.0;
            padding: 10px;
            overflow: auto;
            white-space: pre;
            position: relative;  /* Added for absolute positioning of status */
            display: flex;
            flex-direction: column;
            align-items: center;  /* Center horizontally */
            justify-content: flex-start;  /* Align to top */
        }
        
        .dashboard-wrapper {
            overflow: hidden !important; /* Force clip on mobile */
            max-width: 100%;
            position: relative;
            background-color: #0d0d0d !important; /* Ensure consistent background */
        }

        .dashboard-frame {
            background-color: #0d0d0d !important;  /* Force consistent black background */
            color: #d4d4d4 !important;  /* Force consistent text color */
            padding: 8px;
            border-radius: var(--radius-small);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            display: inline-block;  /* inline-block to fit content width */
            font-family: 'Courier New', Courier, 'Lucida Console', monospace;  /* Use most compatible monospace font */
            font-size: 10px;
            line-height: 1.2;  /* Slightly increase line height for better mobile rendering */
            letter-spacing: 0;  /* Reset letter spacing */
            font-variant-ligatures: none;  /* Disable ligatures that might cause misalignment */
            -webkit-font-smoothing: none;  /* Disable antialiasing for sharper monospace */
            -moz-osx-font-smoothing: auto;
            text-rendering: optimizeSpeed;  /* Force simple text rendering */
            font-feature-settings: "liga" 0, "calt" 0;  /* Disable all font features */
        }
        
        /* Mobile-specific adjustments */
        @media (max-width: 768px) {
            .terminal-container {
                font-size: 8px;
                padding: 5px;
                min-height: auto; /* Let it grow as needed */
                overflow: hidden !important; /* Ensure no clipping */
            }
            
            .dashboard-frame {
                padding: 4px;
                font-size: 8px;
                display: inline-block;  /* Keep inline-block on mobile too */
                overflow: visible; /* No clipping */
                /* Force absolutely consistent character width on mobile */
                font-family: monospace, 'Courier', 'Courier New' !important;
                font-weight: normal !important;
                font-style: normal !important;
                text-transform: none !important;
                word-spacing: 0 !important;
                letter-spacing: 0 !important;
                line-height: 1.0 !important;  /* Tighter line height on mobile */
                -webkit-text-size-adjust: 100%;  /* Prevent iOS font size adjustments */
                -webkit-font-smoothing: none !important;
                text-rendering: optimizeLegibility !important;  /* Better character spacing */
                font-variant-numeric: tabular-nums !important;  /* Force monospace numbers */
            }
            
            /* Ensure terminal content scrolls properly on mobile */
            #terminal-content {
                height: calc(100vh - 120px); /* Account for header and tabs */
                overflow-y: auto;
            }
        }

        .dashboard-line {
            white-space: pre;
            margin: 0;
            padding: 0;
            background-color: transparent !important;  /* Ensure no background color inheritance */
            color: inherit !important;  /* Inherit color from parent */
            font-family: inherit;  /* Inherit monospace font from parent */
            font-size: inherit;
            line-height: inherit;
            letter-spacing: inherit;
        }
        
        /* Spec tab styles */
        .spec-container {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background-color: var(--background);
        }
        
        .spec-section {
            margin-bottom: 30px;
        }
        
        .spec-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 12px;
        }
        
        .spec-metadata {
            font-size: 14px;
            color: var(--light-text);
            margin-bottom: 8px;
            font-family: 'Inter', sans-serif;
        }
        
        .spec-hash {
            font-family: 'Cascadia Code', 'Fira Code', monospace;
            font-size: 13px;
            margin-bottom: 16px;
        }
        
        .spec-code {
            background-color: #f5f5f5;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            font-family: 'Cascadia Code', 'Fira Code', monospace;
            font-size: 13px;
            color: #333;
            white-space: pre;
            overflow-x: auto;
        }
        
        [data-theme="dark"] .spec-code {
            background-color: #1e1e1e;
            color: #e0e0e0;
        }
        
        .terminal-line {
            min-height: 1.4em;
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: transparent;
            color: var(--text);
            padding: 2px 5px;
        }
        
        /* Dark theme adjustments for terminal */
        [data-theme="dark"] .terminal-container {
            background-color: var(--background);
        }
        
        .terminal-status {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
            color: var(--light-text);
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 8px; /* Match tab button vertical padding for alignment */
            border-radius: var(--radius-small);
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: var(--radius-round);
            background-color: #666;
            transition: background-color 0.3s;
        }
        
        .status-indicator.connected {
            background-color: #18453B;
            box-shadow: 0 0 4px rgba(24, 69, 59, 0.4);
        }
        
        /* Iframe-friendly adjustments */
        @media (max-height: 600px) {
            .modal-content {
                max-height: 85vh;
                padding: 20px;
            }

            .form-group {
                margin-bottom: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <div class="logo">
                <div class="logo-icon">P</div>
                <span class="logo-text">Chat</span>
                <span class="logo-separator">|</span>
                <span class="system-prompt-header" id="system-prompt" contenteditable="true" spellcheck="false">Write thy wrong.</span>
            </div>
            <div style="display: flex; align-items: center;">
                <button class="theme-toggle-button" id="theme-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" id="theme-icon">
                        <!-- Moon icon (default for light mode) -->
                        <path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"/>
                    </svg>
                </button>
                <button class="settings-button" id="settings-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M8 4.754a3.246 3.246 0 1 0 0 6.492 3.246 3.246 0 0 0 0-6.492zM5.754 8a2.246 2.246 0 1 1 4.492 0 2.246 2.246 0 0 1-4.492 0z"/>
                        <path d="M9.796 1.343c-.527-1.79-3.065-1.79-3.592 0l-.094.319a.873.873 0 0 1-1.255.52l-.292-.16c-1.64-.892-3.433.902-2.54 2.541l.159.292a.873.873 0 0 1-.52 1.255l-.319.094c-1.79.527-1.79 3.065 0 3.592l.319.094a.873.873 0 0 1 .52 1.255l-.16.292c-.892 1.64.901 3.434 2.541 2.54l.292-.159a.873.873 0 0 1 1.255.52l.094.319c.527 1.79 3.065 1.79 3.592 0l.094-.319a.873.873 0 0 1 1.255-.52l.292.16c1.64.893 3.434-.902 2.54-2.541l-.159-.292a.873.873 0 0 1 .52-1.255l.319-.094c1.79-.527 1.79-3.065 0-3.592l-.319-.094a.873.873 0 0 1-.52-1.255l.16-.292c.893-1.64-.902-3.433-2.541-2.54l-.292.159a.873.873 0 0 1-1.255-.52l-.094-.319zm-2.633.283c.246-.835 1.428-.835 1.674 0l.094.319a1.873 1.873 0 0 0 2.693 1.115l.291-.16c.764-.415 1.6.42 1.184 1.185l-.159.292a1.873 1.873 0 0 0 1.116 2.692l.318.094c.835.246.835 1.428 0 1.674l-.319.094a1.873 1.873 0 0 0-1.115 2.693l.16.291c.415.764-.42 1.6-1.185 1.184l-.291-.159a1.873 1.873 0 0 0-2.693 1.116l-.094.318c-.246.835-1.428.835-1.674 0l-.094-.319a1.873 1.873 0 0 0-2.692-1.115l-.292.16c-.764.415-1.6-.42-1.184-1.185l.159-.291A1.873 1.873 0 0 0 1.945 8.93l-.319-.094c-.835-.246-.835-1.428 0-1.674l.319-.094A1.873 1.873 0 0 0 3.06 4.377l-.16-.292c-.415-.764.42-1.6 1.185-1.184l.292.159a1.873 1.873 0 0 0 2.692-1.115l.094-.319z"/>
                    </svg>
                    Settings
                </button>
            </div>
        </header>
        
        <!-- Tab navigation -->
        <div class="tab-nav">
            <div class="tab-buttons">
                <button class="tab-button active" data-tab="chat" id="chat-tab">Gymnasium</button>
                <button class="tab-button" data-tab="terminal" id="terminal-tab">Terminal</button>
                <button class="tab-button" data-tab="spec" id="spec-tab">Identity</button>
            </div>
            <div class="terminal-status">
                <span class="status-indicator" id="status-indicator"></span>
                <span id="terminal-status">Disconnected</span>
            </div>
        </div>
        
        <!-- Chat tab content -->
        <div class="tab-content active" id="chat-content">
            <div class="chat-container" id="chat-container">
            </div>
            
            <div class="input-container">
                <textarea class="message-input" id="message-input" placeholder="> Shoot" rows="1"></textarea>
            </div>
        </div>
        
        <!-- Terminal tab content -->
        <div class="tab-content" id="terminal-content">
            <div class="terminal-container" id="terminal-display">
                <div class="terminal-line">Terminal ready. Dashboard will connect automatically when available.</div>
            </div>
        </div>
        
        <!-- Spec tab content -->
        <div class="tab-content" id="spec-content">
            <div class="spec-container" id="spec-container">
                <div style="padding: 20px; color: var(--light-text);">Loading specification...</div>
            </div>
        </div>
    </div>

    <div class="settings-modal" id="settings-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Settings</h3>
                <button class="close-button" id="close-modal">&times;</button>
            </div>
            <div class="form-group">
                <label for="api-url">API Server URL</label>
                <input type="text" id="api-url" placeholder="Enter API URL" value="">
            </div>
            
            <h4 style="margin-top: 20px; margin-bottom: 15px; font-weight: 500; color: var(--text);">Generation Parameters</h4>
            
            <div class="form-group">
                <label for="max-tokens">Max New Tokens (50-1000)</label>
                <input type="number" id="max-tokens" min="50" max="1000" value="256">
            </div>
            
            <div class="form-group">
                <label for="temperature">Temperature (0.1-2.0)</label>
                <input type="range" id="temperature" min="0.1" max="2.0" step="0.05" value="0.4">
                <span id="temperature-value">0.4</span>
            </div>
            
            <div class="form-group">
                <label for="repetition-penalty">Repetition Penalty (1.0-2.0)</label>
                <input type="range" id="repetition-penalty" min="1.0" max="2.0" step="0.05" value="1.15">
                <span id="repetition-penalty-value">1.15</span>
            </div>
            
            <div class="form-group">
                <label for="do-sample">
                    <input type="checkbox" id="do-sample" checked>
                    Enable Sampling
                </label>
            </div>
            
            <h4 style="margin-top: 20px; margin-bottom: 15px; font-weight: 500; color: var(--text);">Developer Options</h4>
            
            <div class="form-group">
                <label for="debug-logging">
                    <input type="checkbox" id="debug-logging">
                    Debug Logging
                </label>
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="save-button" id="save-settings">Save Settings</button>
                <button class="reset-button" id="reset-settings">Reset All</button>
            </div>
            <div class="save-confirmation" id="save-confirmation">Settings saved! Refreshing...</div>
        </div>
    </div>

    <!-- Socket.IO for live reload -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <script>
        // Live reload setup
        console.log('Connecting live-reload WebSocket');
        
        // Use the same path logic for live-reload
        const pathname = window.location.pathname;
        let socketPath = '/socket.io';
        
        if (pathname && pathname !== '/') {
            const cleanPath = pathname.replace(/\/$/, '');
            socketPath = cleanPath + '/socket.io';
        }
        
        console.log('Live-reload socket path:', socketPath);
        
        const socket = io.connect('/live-reload', {
            path: socketPath
        });
        
        socket.on('connect', () => {
            console.log('Live reload connected');
        });
        
        socket.on('reload', () => {
            console.log('Template change detected, reloading...');
            window.location.reload();
        });
        
        socket.on('disconnect', () => {
            console.log('Live reload disconnected');
        });
        
        // Chat application logic
        document.addEventListener('DOMContentLoaded', () => {
            // DOM elements
            const chatContainer = document.getElementById('chat-container');
            const messageInput = document.getElementById('message-input');
            const settingsButton = document.getElementById('settings-button');
            
            // Initialize persistent "> " prefix
            const PREFIX = "> ";
            const PLACEHOLDER_TEXT = "Shoot";
            messageInput.value = PREFIX + PLACEHOLDER_TEXT;
            messageInput.style.color = 'var(--light-text)';
            messageInput.style.fontStyle = 'italic';
            
            // Set cursor position after prefix
            const setCursorAfterPrefix = () => {
                messageInput.setSelectionRange(PREFIX.length, PREFIX.length);
            };
            
            // Handle placeholder behavior
            let isShowingPlaceholder = true;
            
            const showPlaceholder = () => {
                if (messageInput.value === PREFIX) {
                    messageInput.value = PREFIX + PLACEHOLDER_TEXT;
                    messageInput.style.color = 'var(--light-text)';
                    messageInput.style.fontStyle = 'italic';
                    isShowingPlaceholder = true;
                    setCursorAfterPrefix();
                }
            };
            
            const hidePlaceholder = () => {
                if (isShowingPlaceholder) {
                    messageInput.value = PREFIX;
                    messageInput.style.color = '';
                    messageInput.style.fontStyle = '';
                    isShowingPlaceholder = false;
                    setCursorAfterPrefix();
                }
            };
            const settingsModal = document.getElementById('settings-modal');
            const closeModalButton = document.getElementById('close-modal');
            const saveSettingsButton = document.getElementById('save-settings');
            const apiUrlInput = document.getElementById('api-url');
            const systemPromptElement = document.getElementById('system-prompt');
            const themeToggleButton = document.getElementById('theme-toggle');
            const themeIcon = document.getElementById('theme-icon');
            
            // Tab elements
            const chatTab = document.getElementById('chat-tab');
            const terminalTab = document.getElementById('terminal-tab');
            const specTab = document.getElementById('spec-tab');
            const chatContent = document.getElementById('chat-content');
            const terminalContent = document.getElementById('terminal-content');
            const specContent = document.getElementById('spec-content');
            
            // Terminal elements
            const terminalDisplay = document.getElementById('terminal-display');
            const terminalStatus = document.getElementById('terminal-status');
            const statusIndicator = document.getElementById('status-indicator');
            
            // Terminal WebSocket
            let terminalSocket = null;
            let terminalConnected = false;
            
            // Generation parameter inputs
            const maxTokensInput = document.getElementById('max-tokens');
            const temperatureInput = document.getElementById('temperature');
            const temperatureValue = document.getElementById('temperature-value');
            const repetitionPenaltyInput = document.getElementById('repetition-penalty');
            const repetitionPenaltyValue = document.getElementById('repetition-penalty-value');
            const doSampleInput = document.getElementById('do-sample');
            const debugLoggingInput = document.getElementById('debug-logging');
            
            // Default API URL is the current server, preserving any path prefix
            let pathPrefix = window.location.pathname;
            
            // Remove trailing slash from pathname if present
            if (pathPrefix.endsWith('/') && pathPrefix !== '/') {
                pathPrefix = pathPrefix.slice(0, -1);
            }
            
            // If we're at root, don't add any prefix
            if (pathPrefix === '/') {
                pathPrefix = '';
            }
            
            // API base URL for all API calls
            const API_BASE_URL = window.location.origin + pathPrefix;
            
            // Construct API URL - note that pathPrefix already includes leading /
            let apiUrl = API_BASE_URL + '/input/';
            
            // Set the default URL in the input field immediately
            apiUrlInput.value = apiUrl;
            
            // Default generation parameters
            let generationParams = {
                max_new_tokens: 256,
                temperature: 0.5,
                repetition_penalty: 1.2,
                do_sample: true,
                use_cache: false
            };
            
            // Debug logging flag
            let debugLogging = false;
            
            // Theme management
            let currentTheme = 'light';
            
            // Theme switching functions
            const sunIcon = `<path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/>`;
            
            const moonIcon = `<path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"/>`;
            
            const setTheme = (theme) => {
                currentTheme = theme;
                if (theme === 'dark') {
                    document.documentElement.setAttribute('data-theme', 'dark');
                    themeIcon.innerHTML = sunIcon; // Show sun when it's dark (to switch to light)
                } else {
                    document.documentElement.removeAttribute('data-theme');
                    themeIcon.innerHTML = moonIcon; // Show moon when it's light (to switch to dark)
                }
                localStorage.setItem('praxis_theme', theme);
            };
            
            const toggleTheme = () => {
                setTheme(currentTheme === 'light' ? 'dark' : 'light');
                
                // Update all message headers when theme changes
                const messages = chatContainer.querySelectorAll('.message');
                messages.forEach(message => {
                    const header = message.querySelector('.message-header');
                    if (header) {
                        const isUser = message.classList.contains('user');
                        const isDarkMode = currentTheme === 'dark';
                        if (isDarkMode) {
                            header.textContent = isUser ? 'Me' : 'You';
                        } else {
                            header.textContent = isUser ? 'You' : 'Me';
                        }
                    }
                });
            };
            
            // Load saved theme
            const loadTheme = () => {
                const savedTheme = localStorage.getItem('praxis_theme') || 'light';
                setTheme(savedTheme);
                
                // Update existing message headers based on loaded theme
                const messages = chatContainer.querySelectorAll('.message');
                messages.forEach(message => {
                    const header = message.querySelector('.message-header');
                    if (header) {
                        const isUser = message.classList.contains('user');
                        const isDarkMode = savedTheme === 'dark';
                        if (isDarkMode) {
                            header.textContent = isUser ? 'Me' : 'You';
                        } else {
                            header.textContent = isUser ? 'You' : 'Me';
                        }
                    }
                });
            };
            
            
            // Get system prompt from element or localStorage
            const getSystemPrompt = () => {
                return systemPromptElement.innerText.trim() || "Write thy wrong.";
            };
            
            // Chat history to maintain conversation context
            let chatHistory = [
                { role: "system", content: getSystemPrompt() },
                // { role: "assistant", content: "Hello! I'm your AI assistant. How can I help you today?" }
            ];
            
            // Load saved settings from localStorage
            const loadSettings = () => {
                // Load theme
                loadTheme();
                
                // Load system prompt
                const savedSystemPrompt = localStorage.getItem('praxis_system_prompt');
                if (savedSystemPrompt) {
                    systemPromptElement.innerHTML = savedSystemPrompt;
                    // Update the first system message in chat history (use text content, not HTML)
                    if (chatHistory.length > 0 && chatHistory[0].role === 'system') {
                        chatHistory[0].content = systemPromptElement.innerText.trim() || "Write thy wrong.";
                    }
                }
                
                // Load API URL
                const savedApiUrl = localStorage.getItem('praxis_api_url');
                if (savedApiUrl) {
                    // Check if we're on ngrok with a secret path
                    if (window.location.hostname.includes('ngrok') && pathPrefix !== '') {
                        // Use the dynamically constructed URL for ngrok with secret
                        apiUrlInput.value = apiUrl;
                        console.log('Using dynamic ngrok URL instead of saved URL');
                    } else {
                        // Use saved URL for normal cases
                        apiUrl = savedApiUrl;
                        apiUrlInput.value = savedApiUrl;
                    }
                } else {
                    apiUrlInput.value = apiUrl;
                }
                
                // Load generation parameters
                const savedParams = localStorage.getItem('praxis_gen_params');
                if (savedParams) {
                    try {
                        const params = JSON.parse(savedParams);
                        generationParams = { ...generationParams, ...params };
                        
                        // Update UI elements with saved values
                        maxTokensInput.value = generationParams.max_new_tokens;
                        temperatureInput.value = generationParams.temperature;
                        temperatureValue.textContent = generationParams.temperature;
                        repetitionPenaltyInput.value = generationParams.repetition_penalty;
                        repetitionPenaltyValue.textContent = generationParams.repetition_penalty;
                        doSampleInput.checked = generationParams.do_sample;
                    } catch (error) {
                        console.error('Error loading saved generation parameters:', error);
                    }
                }
                
                // Load debug logging setting
                const savedDebugLogging = localStorage.getItem('praxis_debug_logging');
                if (savedDebugLogging === 'true') {
                    debugLogging = true;
                    debugLoggingInput.checked = true;
                }
                
            };
            
            // Test API connectivity
            const testApiConnection = async (url) => {
                try {
                    // Format the URL for ping endpoint
                    let baseUrl = url;
                    
                    // Remove the '/input/' path if it exists
                    if (baseUrl.endsWith('/input/')) {
                        baseUrl = baseUrl.substring(0, baseUrl.length - 7);
                    }
                    
                    // Ensure URL has http:// or https:// prefix
                    if (!baseUrl.startsWith('http://') && !baseUrl.startsWith('https://')) {
                        baseUrl = 'http://' + baseUrl;
                    }
                    
                    // Remove trailing slash if it exists
                    if (baseUrl.endsWith('/')) {
                        baseUrl = baseUrl.substring(0, baseUrl.length - 1);
                    }
                    
                    const pingUrl = `${baseUrl}/api/ping`;
                    console.log(`Testing API connection to: ${pingUrl}`);
                    
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Connection test timed out')), 15000)
                    );
                    
                    const fetchPromise = fetch(pingUrl, {
                        method: 'GET',
                        mode: 'cors',
                        credentials: 'omit'
                    });
                    
                    const response = await Promise.race([fetchPromise, timeoutPromise]);
                    
                    // Check if response is OK
                    if (!response.ok) {
                        return { success: false, message: `Server returned ${response.status} ${response.statusText}` };
                    }
                    
                    // Try to parse as JSON, but handle non-JSON responses
                    let result;
                    const contentType = response.headers.get('content-type');
                    if (contentType && contentType.includes('application/json')) {
                        result = await response.json();
                    } else {
                        // If not JSON, just check that we got a response
                        const text = await response.text();
                        console.log('Non-JSON response:', text);
                        result = { message: 'Connected (non-JSON response)' };
                    }
                    
                    console.log('API connection test result:', result);
                    return { success: true, message: result.message || 'Connected to API server' };
                } catch (error) {
                    console.error('API connection test failed:', error);
                    // Provide a cleaner error message
                    if (error.message.includes('Failed to fetch')) {
                        return { success: false, message: 'Could not reach the server. Check if it\'s running.' };
                    }
                    return { success: false, message: 'Connection failed: ' + error.message };
                }
            };
            
            // Save settings to localStorage
            const saveSettings = async () => {
                // Save API URL
                const newApiUrl = apiUrlInput.value.trim();
                if (newApiUrl) {
                    // Test the connection before saving
                    const connectionTest = await testApiConnection(newApiUrl);
                    
                    // Save generation parameters
                    generationParams = {
                        max_new_tokens: parseInt(maxTokensInput.value, 10),
                        temperature: parseFloat(temperatureInput.value),
                        repetition_penalty: parseFloat(repetitionPenaltyInput.value),
                        do_sample: doSampleInput.checked
                    };
                    
                    // Store parameters
                    localStorage.setItem('praxis_gen_params', JSON.stringify(generationParams));
                    
                    // Save debug logging preference
                    debugLogging = debugLoggingInput.checked;
                    localStorage.setItem('praxis_debug_logging', debugLogging.toString());
                    
                    if (connectionTest.success) {
                        apiUrl = newApiUrl;
                        localStorage.setItem('praxis_api_url', newApiUrl);
                        
                        // Show confirmation message
                        const confirmationDiv = document.getElementById('save-confirmation');
                        confirmationDiv.textContent = 'Connection successful! Settings saved. Refreshing...';
                        confirmationDiv.classList.add('show');
                        
                        // Refresh after showing message
                        setTimeout(() => window.location.reload(), 2000);
                    } else {
                        // Save without showing confirm dialog
                        console.warn('API connection warning:', connectionTest.message);
                        apiUrl = newApiUrl;
                        localStorage.setItem('praxis_api_url', newApiUrl);
                        
                        // Show confirmation message with warning note
                        const confirmationDiv = document.getElementById('save-confirmation');
                        confirmationDiv.textContent = 'Settings saved (check console for connection details)';
                        confirmationDiv.classList.add('show');
                        
                        // Refresh after showing message
                        setTimeout(() => window.location.reload(), 2000);
                    }
                } else {
                    // Save only the generation parameters
                    generationParams = {
                        max_new_tokens: parseInt(maxTokensInput.value, 10),
                        temperature: parseFloat(temperatureInput.value),
                        repetition_penalty: parseFloat(repetitionPenaltyInput.value),
                        do_sample: doSampleInput.checked
                    };
                    
                    localStorage.setItem('praxis_gen_params', JSON.stringify(generationParams));
                    
                    // Save debug logging preference
                    debugLogging = debugLoggingInput.checked;
                    localStorage.setItem('praxis_debug_logging', debugLogging.toString());
                    
                    // Show confirmation message
                    const confirmationDiv = document.getElementById('save-confirmation');
                    confirmationDiv.textContent = 'Generation parameters saved!';
                    confirmationDiv.classList.add('show');
                    
                    // Hide message after 2 seconds
                    setTimeout(() => {
                        confirmationDiv.classList.remove('show');
                    }, 2000);
                }
            };
            
            // Open settings modal
            const openModal = () => {
                settingsModal.classList.add('open');
            };
            
            // Close settings modal
            const closeModal = () => {
                settingsModal.classList.remove('open');
            };
            
            // Add a new message to the chat
            const addMessage = (content, isUser) => {
                // Add to visual chat
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${isUser ? 'user' : 'assistant'}`;
                
                // Add with-messages class to input container when first message is added
                const inputContainer = document.querySelector('.input-container');
                if (inputContainer && !inputContainer.classList.contains('with-messages')) {
                    inputContainer.classList.add('with-messages');
                }
                
                const headerDiv = document.createElement('div');
                headerDiv.className = 'message-header';
                
                // Check if content is empty for assistant messages
                if (!isUser && (!content || content.trim() === '')) {
                    headerDiv.innerHTML = '<span class="error-header">[ERR]</span>';
                    // Don't add any content div for empty responses
                    messageDiv.appendChild(headerDiv);
                } else {
                    // Swap labels in dark mode
                    const isDarkMode = document.documentElement.getAttribute('data-theme') === 'dark';
                    if (isDarkMode) {
                        headerDiv.textContent = isUser ? 'Me' : 'You';
                    } else {
                        headerDiv.textContent = isUser ? 'You' : 'Me';
                    }
                    
                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'message-content';
                    contentDiv.textContent = content;
                    
                    messageDiv.appendChild(headerDiv);
                    messageDiv.appendChild(contentDiv);
                }
                
                // Add reroll button for assistant messages
                if (!isUser) {
                    const rerollButton = document.createElement('button');
                    rerollButton.className = 'reroll-button';
                    rerollButton.innerHTML = `
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M1 4v6h6M23 20v-6h-6"/>
                            <path d="M20.49 9A9 9 0 1 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"/>
                        </svg>
                        Retry
                    `;
                    rerollButton.onclick = handleReroll;
                    messageDiv.appendChild(rerollButton);
                }
                
                chatContainer.appendChild(messageDiv);
                
                // Smooth scroll to bottom after adding message
                requestAnimationFrame(() => {
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                });
                
                // Add to chat history
                chatHistory.push({
                    role: isUser ? 'user' : 'assistant',
                    content: content
                });
            };
            
            // Show thinking indicator
            const showThinking = () => {
                // Create a proper assistant message container
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message assistant';
                messageDiv.id = 'thinking-indicator';
                
                // Add header with thinking text
                const headerDiv = document.createElement('div');
                headerDiv.className = 'message-header';
                
                // Use appropriate label based on theme
                const isDarkMode = document.documentElement.getAttribute('data-theme') === 'dark';
                
                // Build the header text correctly
                let headerContent;
                if (isDarkMode) {
                    // "You" + " are thinking" (with space)
                    headerContent = `
                        <span class="header-name">You</span>
                        <span class="thinking-status"> are thinking</span>
                    `;
                } else {
                    // "Meandering" as one word
                    headerContent = `
                        <span class="header-name">Meandering</span>
                    `;
                }
                
                // Create header with text and dots all on one line
                headerDiv.innerHTML = headerContent + `
                    <div class="dots">
                        <div class="dot"></div>
                        <div class="dot"></div>
                        <div class="dot"></div>
                    </div>
                `;
                
                // Only append the header - no content div until we have actual content
                messageDiv.appendChild(headerDiv);
                
                // Add a timer to update the thinking indicator after a minute
                let thinkingTimeSeconds = 0;
                const thinkingTimer = setInterval(() => {
                    thinkingTimeSeconds += 1;
                    
                    // After 60 seconds, show a time indicator
                    if (thinkingTimeSeconds >= 60) {
                        const minutes = Math.floor(thinkingTimeSeconds / 60);
                        const seconds = thinkingTimeSeconds % 60;
                        const timeDisplay = `${minutes}m ${seconds}s`;
                        
                        const timerElement = document.createElement('span');
                        timerElement.className = 'thinking-timer';
                        timerElement.textContent = ` (${timeDisplay})`;
                        timerElement.style.fontSize = '12px';
                        timerElement.style.color = 'var(--light-text)';
                        
                        // Replace previous timer if exists
                        const existingTimer = headerDiv.querySelector('.thinking-timer');
                        if (existingTimer) {
                            existingTimer.textContent = ` (${timeDisplay})`;
                        } else {
                            headerDiv.querySelector('.thinking-status').appendChild(timerElement);
                        }
                    }
                }, 1000);
                
                // Store the timer reference so we can clear it later
                messageDiv.dataset.timerId = thinkingTimer;
                
                chatContainer.appendChild(messageDiv);
                chatContainer.scrollTop = chatContainer.scrollHeight;
            };
            
            // Hide thinking indicator
            const hideThinking = () => {
                const thinkingDiv = document.getElementById('thinking-indicator');
                if (thinkingDiv) {
                    // Clear the timer if it exists
                    if (thinkingDiv.dataset.timerId) {
                        clearInterval(parseInt(thinkingDiv.dataset.timerId));
                    }
                    thinkingDiv.remove();
                }
            };
            
            // Handle reroll button click
            const handleReroll = async () => {
                // Find the last user message in chat history
                let lastUserMessage = null;
                for (let i = chatHistory.length - 1; i >= 0; i--) {
                    if (chatHistory[i].role === 'user') {
                        lastUserMessage = chatHistory[i].content;
                        break;
                    }
                }
                
                if (!lastUserMessage) return;
                
                // Remove the last assistant message from both visual chat and history
                const assistantMessages = chatContainer.querySelectorAll('.message.assistant');
                if (assistantMessages.length > 0) {
                    const lastAssistantMessage = assistantMessages[assistantMessages.length - 1];
                    lastAssistantMessage.remove();
                }
                
                // Remove last assistant message from chat history
                if (chatHistory[chatHistory.length - 1].role === 'assistant') {
                    chatHistory.pop();
                }
                
                // Resend the message
                await sendMessageToAPI(lastUserMessage);
            };
            
            // Send message to API
            const sendMessage = async () => {
                // Don't send if showing placeholder
                if (isShowingPlaceholder) return;
                
                const fullValue = messageInput.value;
                
                // Extract message without the prefix
                const message = fullValue.startsWith(PREFIX) 
                    ? fullValue.slice(PREFIX.length).trim() 
                    : fullValue.trim();
                
                if (!message) return;
                
                // Add user message to chat
                addMessage(message, true);
                
                // Clear input but keep it ready (no placeholder while focused)
                messageInput.value = PREFIX;
                messageInput.style.color = '';
                messageInput.style.fontStyle = '';
                isShowingPlaceholder = false;
                setCursorAfterPrefix();
                
                // Send the message
                await sendMessageToAPI(message);
            };
            
            // Core function to send message to API
            const sendMessageToAPI = async (message) => {
                // Show thinking indicator
                showThinking();
                
                try {
                    // Update system prompt in chat history before sending
                    if (chatHistory.length > 0 && chatHistory[0].role === 'system') {
                        chatHistory[0].content = getSystemPrompt();
                    }
                    
                    // Prepare the request with full chat history and generation parameters
                    const historyLength = 23
                    const requestBody = {
                        messages: chatHistory.slice(-historyLength),
                        // Use saved generation parameters
                        ...generationParams
                    };
                    
                    // Debug logging
                    if (debugLogging) {
                        console.group('🤖 AI Request Debug');
                        console.log('Request URL:', apiUrl);
                        console.log('Full Request Payload:');
                        console.log(JSON.parse(JSON.stringify(requestBody))); // Deep copy to avoid console reference issues
                        console.log('Messages Array:');
                        requestBody.messages.forEach((msg, index) => {
                            console.log(`[${index}] ${msg.role}:`, msg.content);
                        });
                        console.log('Generation Parameters:', {
                            max_new_tokens: requestBody.max_new_tokens,
                            temperature: requestBody.temperature,
                            repetition_penalty: requestBody.repetition_penalty,
                            do_sample: requestBody.do_sample
                        });
                        console.groupEnd();
                    }
                    
                    // Use a timeout promise to handle network issues - 5 minute timeout for LLM responses
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Request timed out after 5 minutes')), 5 * 60 * 1000)
                    );
                    
                    // Make sure URL is properly formatted
                    let formattedUrl = apiUrl;
                    
                    // Ensure URL has http:// or https:// prefix
                    if (!formattedUrl.startsWith('http://') && !formattedUrl.startsWith('https://')) {
                        formattedUrl = 'http://' + formattedUrl;
                    }
                    
                    // Ensure URL has trailing slash for API
                    if (!formattedUrl.endsWith('/')) {
                        formattedUrl = formattedUrl + '/';
                    }
                    
                    console.log('Final formatted URL being fetched:', formattedUrl);
                    
                    // Send request to API with timeout
                    const fetchPromise = fetch(formattedUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody),
                        mode: 'cors', // Explicitly request CORS
                        credentials: 'omit' // Don't send cookies to avoid extra CORS preflight
                    });
                    
                    // Race between fetch and timeout
                    const response = await Promise.race([fetchPromise, timeoutPromise]);
                    
                    // Check if request was successful
                    if (!response.ok) {
                        const errorText = await response.text().catch(() => '');
                        throw new Error(`API error: ${response.status} - ${errorText || response.statusText}`);
                    }
                    
                    // Parse response
                    const result = await response.json();
                    
                    // Debug logging for response
                    if (debugLogging) {
                        console.group('🤖 AI Response Debug');
                        console.log('Response Status:', response.status);
                        console.log('Response Data:', result);
                        console.groupEnd();
                    }
                    
                    // Hide thinking indicator
                    hideThinking();
                    
                    // Add assistant response to chat
                    addMessage(result.response, false);
                    
                } catch (error) {
                    console.error('Error sending message:', error);
                    
                    // Hide thinking indicator
                    hideThinking();
                    
                    // Determine error message based on error type
                    let errorMessage = "Sorry, there was an error processing your request. Please check your connection or API settings and try again.";
                    
                    if (error.message.includes('NetworkError') || error.message.includes('Failed to fetch') || error.message.includes('timed out')) {
                        errorMessage = `Network error: Unable to connect to the API server at "${apiUrl}". Please check that the server is running and accessible.`;
                    } else if (error.message.includes('CORS')) {
                        errorMessage = `CORS error: The API server at "${apiUrl}" is not allowing requests from this webpage. Please ensure CORS is properly configured on the server.`;
                    } else if (error.message.includes('API error')) {
                        errorMessage = `Server error: ${error.message}. Please check your API server configuration.`;
                    }
                    
                    // Add error message
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'message assistant';
                    errorDiv.innerHTML = `
                        <div class="message-header">Me</div>
                        <div class="message-content">${errorMessage}</div>
                    `;
                    chatContainer.appendChild(errorDiv);
                }
                
                // Scroll to bottom
                chatContainer.scrollTop = chatContainer.scrollHeight;
            };
            
            // Auto-resize textarea as user types
            const autoResizeTextarea = () => {
                messageInput.style.height = 'auto';
                messageInput.style.height = messageInput.scrollHeight + 'px';
            };
            
            // Event listeners
            messageInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                    return;
                }
                
                // Prevent cursor from moving before prefix
                const cursorPos = messageInput.selectionStart;
                if ((e.key === 'ArrowLeft' || e.key === 'Home' || e.key === 'Backspace') && cursorPos <= PREFIX.length) {
                    if (e.key === 'Backspace' && cursorPos === PREFIX.length) {
                        // Allow backspace at prefix end, but don't delete prefix
                        e.preventDefault();
                    } else if (e.key === 'ArrowLeft' && cursorPos === PREFIX.length) {
                        // Don't move cursor before prefix
                        e.preventDefault();
                    } else if (e.key === 'Home') {
                        // Home key should go to after prefix, not beginning
                        e.preventDefault();
                        setCursorAfterPrefix();
                    }
                }
            });
            
            // Maintain prefix on input
            const maintainPrefix = () => {
                // Store the actual typed character if placeholder is showing
                const currentValue = messageInput.value;
                const cursorPos = messageInput.selectionStart;
                
                // Hide placeholder on any input
                if (isShowingPlaceholder) {
                    // Extract any new characters typed after the placeholder
                    const newChars = currentValue.replace(PREFIX + PLACEHOLDER_TEXT, '').replace(PREFIX, '');
                    hidePlaceholder();
                    // Re-add the typed characters
                    if (newChars) {
                        messageInput.value = PREFIX + newChars;
                        messageInput.setSelectionRange(messageInput.value.length, messageInput.value.length);
                    }
                    return;
                }
                
                // If prefix was deleted or modified, restore it
                if (!currentValue.startsWith(PREFIX)) {
                    const userText = currentValue.replace(/^[>\s]*/, ''); // Remove any partial prefix attempts
                    messageInput.value = PREFIX + userText;
                    
                    // Adjust cursor position 
                    const newCursorPos = Math.max(PREFIX.length, cursorPos + PREFIX.length - (currentValue.length - userText.length));
                    messageInput.setSelectionRange(newCursorPos, newCursorPos);
                }
                
                // Auto-resize after maintaining prefix
                autoResizeTextarea();
            };
            
            messageInput.addEventListener('input', maintainPrefix);
            
            // Ensure cursor stays after prefix on focus and click
            messageInput.addEventListener('focus', () => {
                hidePlaceholder();
                setTimeout(setCursorAfterPrefix, 0);
            });
            
            messageInput.addEventListener('blur', () => {
                showPlaceholder();
            });
            
            messageInput.addEventListener('click', () => {
                if (isShowingPlaceholder) {
                    hidePlaceholder();
                }
                const cursorPos = messageInput.selectionStart;
                if (cursorPos < PREFIX.length) {
                    setCursorAfterPrefix();
                }
            });
            
            themeToggleButton.addEventListener('click', toggleTheme);
            settingsButton.addEventListener('click', openModal);
            closeModalButton.addEventListener('click', closeModal);
            saveSettingsButton.addEventListener('click', () => {
                // Call the async function properly in the event handler
                saveSettings().catch(err => {
                    console.error('Error in save settings:', err);
                    // Show error message
                    const confirmationDiv = document.getElementById('save-confirmation');
                    confirmationDiv.textContent = 'Error saving settings. Check console.';
                    confirmationDiv.style.backgroundColor = '#d32f2f';
                    confirmationDiv.classList.add('show');
                    
                    // Hide after 3 seconds
                    setTimeout(() => {
                        confirmationDiv.classList.remove('show');
                        confirmationDiv.style.backgroundColor = '';
                    }, 3000);
                });
            });
            
            // Reset button handler
            const resetButton = document.getElementById('reset-settings');
            resetButton.addEventListener('click', () => {
                // Clear all localStorage items for this page
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    // Remove all praxis-related keys
                    if (key && (key.startsWith('praxis_') || key === 'theme' || key === 'chatHistory')) {
                        keysToRemove.push(key);
                    }
                }
                
                // Remove all collected keys
                keysToRemove.forEach(key => localStorage.removeItem(key));
                
                // Show confirmation and reload
                const confirmationDiv = document.getElementById('save-confirmation');
                confirmationDiv.textContent = 'All settings cleared! Refreshing...';
                confirmationDiv.classList.add('show');
                
                // Reload the page after a short delay
                setTimeout(() => window.location.reload(), 1500);
            });
            
            // Set up parameter input event listeners for sliders
            temperatureInput.addEventListener('input', () => {
                temperatureValue.textContent = temperatureInput.value;
            });
            
            repetitionPenaltyInput.addEventListener('input', () => {
                repetitionPenaltyValue.textContent = repetitionPenaltyInput.value;
            });
            
            // Click outside modal to close
            settingsModal.addEventListener('click', (e) => {
                if (e.target === settingsModal) {
                    closeModal();
                }
            });
            
            // System prompt editing - real-time updates
            let systemPromptUpdateTimeout;
            
            systemPromptElement.addEventListener('input', () => {
                const newPrompt = systemPromptElement.innerHTML.trim();
                const newPromptText = systemPromptElement.innerText.trim() || "Write thy wrong.";
                
                // Debounce localStorage updates to avoid excessive writes
                clearTimeout(systemPromptUpdateTimeout);
                systemPromptUpdateTimeout = setTimeout(() => {
                    localStorage.setItem('praxis_system_prompt', newPrompt);
                    // Update system prompt in chat history (use innerText for API)
                    if (chatHistory.length > 0 && chatHistory[0].role === 'system') {
                        chatHistory[0].content = newPromptText;
                    }
                }, 500); // 500ms debounce
            });
            
            // Keep blur handler for final save (in case input event doesn't fire)
            systemPromptElement.addEventListener('blur', () => {
                const newPrompt = systemPromptElement.innerHTML.trim();
                const newPromptText = systemPromptElement.innerText.trim() || "Write thy wrong.";
                
                localStorage.setItem('praxis_system_prompt', newPrompt);
                // Update system prompt in chat history (use innerText for API)
                if (chatHistory.length > 0 && chatHistory[0].role === 'system') {
                    chatHistory[0].content = newPromptText;
                }
            });
            
            // Simple mobile improvements without janky behavior
            // Just ensure chat scrolls to bottom when new messages are added
            const scrollToBottom = () => {
                requestAnimationFrame(() => {
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                });
            };
            
            // Function to ensure last message is visible
            const ensureLastMessageVisible = () => {
                // Always scroll to absolute bottom first
                chatContainer.scrollTop = chatContainer.scrollHeight;
                
                // Then check if we need to adjust
                const messages = chatContainer.querySelectorAll('.message');
                if (messages.length > 0) {
                    const lastMessage = messages[messages.length - 1];
                    const chatRect = chatContainer.getBoundingClientRect();
                    const messageRect = lastMessage.getBoundingClientRect();
                    
                    // Get the visual viewport height if available (accounts for keyboard)
                    const viewportHeight = window.visualViewport ? 
                        window.visualViewport.height : 
                        window.innerHeight;
                    
                    // Calculate where the input area starts (accounting for keyboard)
                    const inputTop = viewportHeight - 100; // Approximate input + keyboard height
                    
                    // If the last message extends below where the input starts
                    if (messageRect.bottom > inputTop) {
                        // Scroll the chat so the message is fully visible
                        const scrollOffset = messageRect.bottom - inputTop + 30; // 30px padding
                        chatContainer.scrollTop = Math.max(0, chatContainer.scrollTop + scrollOffset);
                    }
                }
            };
            
            // When input is focused, ensure last message is visible above keyboard
            messageInput.addEventListener('focus', () => {
                // Initial scroll
                ensureLastMessageVisible();
                
                // Do it again after keyboard animation completes
                setTimeout(ensureLastMessageVisible, 350);
                
                // And once more for good measure (some keyboards animate slowly)
                setTimeout(ensureLastMessageVisible, 600);
            });
            
            // If Visual Viewport API is available, use it for better keyboard detection
            if (window.visualViewport) {
                let previousHeight = window.visualViewport.height;
                
                window.visualViewport.addEventListener('resize', () => {
                    const currentHeight = window.visualViewport.height;
                    
                    // Keyboard likely appeared if viewport got smaller
                    if (currentHeight < previousHeight && document.activeElement === messageInput) {
                        setTimeout(ensureLastMessageVisible, 100);
                    }
                    
                    previousHeight = currentHeight;
                });
            }
            
            
            // Store dashboard scale outside to make it accessible
            let dashboardScale = null;
            let currentTab = 'chat'; // Track current tab
            let currentFrameContainer = null; // Store reference to current frame
            let currentWrapperDiv = null; // Store reference to current wrapper
            
            // Function to recalculate dashboard scale (for orientation changes)
            function recalculateDashboardScale() {
                if (!currentFrameContainer || !currentWrapperDiv || currentTab !== 'terminal') {
                    return;
                }
                
                // Reset scale
                dashboardScale = null;
                
                // Get natural dimensions (remove any existing transform first)
                currentFrameContainer.style.transform = 'none';
                const naturalWidth = currentFrameContainer.scrollWidth;
                const naturalHeight = currentFrameContainer.scrollHeight;
                
                // Lock the frame to its natural size
                currentFrameContainer.style.width = naturalWidth + 'px';
                currentFrameContainer.style.height = naturalHeight + 'px';
                currentFrameContainer.style.maxWidth = naturalWidth + 'px';
                currentFrameContainer.style.overflow = 'hidden';
                
                // Calculate scale based on current viewport
                const containerWidth = terminalDisplay.clientWidth;
                const containerHeight = terminalDisplay.clientHeight || window.innerHeight * 0.6;
                const padding = 20;
                
                // Calculate scale to fit within BOTH width and height constraints
                const widthScale = (containerWidth - padding) / naturalWidth;
                const heightScale = (containerHeight - padding) / naturalHeight;
                
                // Use the smaller scale to maintain aspect ratio
                dashboardScale = Math.min(widthScale, heightScale);
                
                // On mobile, cap scale at 1.0 for portrait, allow larger for landscape
                const isMobile = window.innerWidth <= 768 || window.innerHeight <= 768;
                const isLandscape = window.innerWidth > window.innerHeight;
                
                if (isMobile && !isLandscape && dashboardScale > 1) {
                    dashboardScale = 1;
                } else if (isMobile && isLandscape && dashboardScale > 1.5) {
                    dashboardScale = 1.5; // Allow some scaling up in landscape
                }
                
                // Apply scale transform
                currentFrameContainer.style.transform = `scale(${dashboardScale})`;
                currentFrameContainer.style.transformOrigin = 'top left';
                
                // Set wrapper dimensions
                const scaledHeight = naturalHeight * dashboardScale;
                const scaledWidth = naturalWidth * dashboardScale;
                
                currentWrapperDiv.style.width = scaledWidth + 'px';
                currentWrapperDiv.style.height = scaledHeight + 'px';
                currentWrapperDiv.style.overflow = 'hidden';
                
                // Always center the wrapper
                currentWrapperDiv.style.margin = '0 auto';
                currentWrapperDiv.style.display = 'block';
                
                terminalDisplay.style.minHeight = (scaledHeight + padding) + 'px';
            }
            
            // Handle orientation changes
            window.addEventListener('orientationchange', () => {
                // Wait for the orientation change to complete
                setTimeout(() => {
                    recalculateDashboardScale();
                }, 100);
            });
            
            // Also handle resize events (for desktop browser window resizing)
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    recalculateDashboardScale();
                }, 250);
            });
            
            // Tab switching functionality
            function switchTab(tabName) {
                currentTab = tabName;
                
                // Update tab buttons
                document.querySelectorAll('.tab-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
                
                // Update tab content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                if (tabName === 'chat') {
                    chatContent.classList.add('active');
                    // Update status to show disconnected when not viewing terminal
                    updateConnectionStatus();
                } else if (tabName === 'terminal') {
                    terminalContent.classList.add('active');
                    // Reset scale when switching to terminal tab
                    dashboardScale = null;
                    // Connect to terminal if not connected
                    if (!terminalConnected) {
                        connectTerminal();
                    }
                    // Update status immediately
                    updateConnectionStatus();
                    // Auto-start capture to show existing dashboard
                    setTimeout(() => {
                        if (terminalConnected) {
                            startTerminalCapture();
                        }
                        // Recalculate scale after switching tabs
                        setTimeout(() => {
                            recalculateDashboardScale();
                        }, 200);
                    }, 100);
                } else if (tabName === 'spec') {
                    specContent.classList.add('active');
                    // Load spec data if not already loaded
                    loadSpec();
                    // Update status to show disconnected when not viewing terminal
                    updateConnectionStatus();
                }
            }
            
            // Update connection status based on both connection and tab
            function updateConnectionStatus() {
                if (currentTab === 'terminal' && terminalConnected) {
                    terminalStatus.textContent = 'Connected';
                    statusIndicator.classList.add('connected');
                } else {
                    terminalStatus.textContent = 'Disconnected';
                    statusIndicator.classList.remove('connected');
                }
            }
            
            // Terminal WebSocket functions
            function connectTerminal() {
                if (terminalSocket && terminalSocket.connected) {
                    return;
                }
                
                // Connect to terminal namespace
                console.log('Connecting to terminal WebSocket');
                console.log('Current location:', window.location.href);
                
                // When served through ngrok with a secret path, socket.io needs to use that path
                const pathname = window.location.pathname;
                let socketPath = '/socket.io';
                
                // If we're on a subpath (ngrok), prepend it to the socket.io path
                if (pathname && pathname !== '/') {
                    // Remove trailing slash and add /socket.io
                    const cleanPath = pathname.replace(/\/$/, '');
                    socketPath = cleanPath + '/socket.io';
                }
                
                console.log('Using socket.io path:', socketPath);
                
                terminalSocket = io.connect('/terminal', {
                    path: socketPath
                });
                
                terminalSocket.on('connect', () => {
                    console.log('Terminal WebSocket connected');
                    terminalConnected = true;
                    updateConnectionStatus();
                });
                
                terminalSocket.on('disconnect', () => {
                    console.log('Terminal WebSocket disconnected');
                    terminalConnected = false;
                    updateConnectionStatus();
                });
                
                terminalSocket.on('connect_error', (error) => {
                    console.error('Terminal WebSocket connection error:', error);
                    console.error('Error type:', error.type);
                    console.error('Error message:', error.message);
                });
                
                terminalSocket.on('terminal_output', (data) => {
                    appendTerminalOutput(data.data);
                });
                
                terminalSocket.on('dashboard_frame', (data) => {
                    if (data.frame && Array.isArray(data.frame)) {
                        terminalDisplay.innerHTML = '';
                        
                        // Create a wrapper container for proper scaling and clipping
                        const wrapperDiv = document.createElement('div');
                        wrapperDiv.style.position = 'relative';
                        wrapperDiv.style.overflow = 'hidden'; // Critical for clipping
                        wrapperDiv.style.backgroundColor = '#0d0d0d'; // Match dashboard bg
                        wrapperDiv.style.display = 'block';
                        wrapperDiv.style.margin = '0 auto'; // Center by default
                        
                        // Create the frame container
                        const frameContainer = document.createElement('div');
                        frameContainer.className = 'dashboard-frame';
                        
                        // Only apply character replacement on actual mobile devices (not just small screens)
                        // Desktop users with small windows should still see original characters
                        const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                        
                        // Add each line
                        data.frame.forEach(line => {
                            const lineDiv = document.createElement('div');
                            lineDiv.className = 'dashboard-line';
                            
                            // On mobile devices only, replace Unicode box drawing and block characters with ASCII
                            // This fixes character width issues on mobile while preserving desktop appearance
                            if (isMobileDevice) {
                                // Replace block/square characters that render as double-width
                                line = line.replace(/[█▓▒░]/g, '#')  // Full blocks -> hash
                                          .replace(/[▀▄]/g, '=')  // Half blocks -> equals
                                          .replace(/[▌▐]/g, '|')  // Left/right half blocks -> pipe
                                          .replace(/[■□▪▫]/g, '#')  // Square blocks -> hash
                                          .replace(/[◼◻◾◽]/g, '#')  // Other squares -> hash
                                          .replace(/[▬▭▮▯]/g, '#')  // Rectangle blocks -> hash
                                          // Horizontal line characters used in charts
                                          .replace(/[═]/g, '=')  // Double horizontal line
                                          .replace(/[─━]/g, '-')  // Single horizontal lines
                                          .replace(/[╌╍┄┅┈┉]/g, '-')  // Dashed lines
                                          .replace(/[⎯⎼⎽]/g, '-')  // Other horizontal lines
                                          .replace(/[▁▂▃▄▅▆▇]/g, '_')  // Bottom blocks for charts
                                          .replace(/[⌐¬]/g, '-')  // Corner lines
                                          .replace(/[·•◦]/g, '*')  // Bullet points
                                          .replace(/[◯○]/g, 'o')  // Circles
                                          .replace(/[●◉]/g, '*')  // Filled circles
                                          // Vertical lines
                                          .replace(/[║]/g, '|')  // Double vertical
                                          .replace(/[┃│|]/g, '|')  // Single vertical lines
                                          .replace(/[╎╏┆┇┊┋]/g, '|')  // Dashed vertical
                                          // Box-drawing corners and junctions
                                          .replace(/[┏┌┍┎╔╒╓╭]/g, '+')  // Top-left corners
                                          .replace(/[┓┐┑┒╗╕╖╮]/g, '+')  // Top-right corners
                                          .replace(/[┗└┕┖╚╘╙╰]/g, '+')  // Bottom-left corners
                                          .replace(/[┛┘┙┚╝╛╜╯]/g, '+')  // Bottom-right corners
                                          .replace(/[┣├┝┞┟┠┡┢╟╞╠]/g, '+')  // Left T-junctions
                                          .replace(/[┫┤┥┦┧┨┩┪╢╡╣]/g, '+')  // Right T-junctions
                                          .replace(/[┳┬┭┮┯┰┱┲╦╤╥]/g, '+')  // Top T-junctions
                                          .replace(/[┻┴┵┶┷┸┹┺╩╧╨]/g, '+')  // Bottom T-junctions
                                          .replace(/[╋┼┽┾┿╀╁╂╬╪╫]/g, '+');  // Cross junctions
                            }
                            
                            lineDiv.textContent = line;
                            frameContainer.appendChild(lineDiv);
                        });
                        
                        // Add frame to wrapper, then wrapper to display
                        wrapperDiv.appendChild(frameContainer);
                        terminalDisplay.appendChild(wrapperDiv);
                        
                        // Store references for orientation changes
                        currentFrameContainer = frameContainer;
                        currentWrapperDiv = wrapperDiv;
                        
                        // Calculate scale only once
                        if (dashboardScale === null) {
                            requestAnimationFrame(() => {
                                // Get natural dimensions
                                const naturalWidth = frameContainer.scrollWidth;
                                const naturalHeight = frameContainer.scrollHeight;
                                
                                // Lock the frame to its natural size
                                frameContainer.style.width = naturalWidth + 'px';
                                frameContainer.style.height = naturalHeight + 'px';
                                frameContainer.style.maxWidth = naturalWidth + 'px';
                                frameContainer.style.overflow = 'hidden';
                                
                                // Calculate scale based on container constraints
                                const containerWidth = terminalDisplay.clientWidth;
                                const containerHeight = terminalDisplay.clientHeight || window.innerHeight * 0.6;
                                const padding = 20;
                                
                                // Calculate scale to fit within BOTH width and height constraints
                                const widthScale = (containerWidth - padding) / naturalWidth;
                                const heightScale = (containerHeight - padding) / naturalHeight;
                                
                                // Use the smaller scale to maintain aspect ratio
                                // Also cap at 1.5x to prevent over-enlargement on mobile
                                dashboardScale = Math.min(widthScale, heightScale, 1.5);
                                
                                // Only scale down on mobile, never up beyond original size
                                if (window.innerWidth <= 768 && dashboardScale > 1) {
                                    dashboardScale = 1;
                                }
                                
                                // Apply scale transform
                                frameContainer.style.transform = `scale(${dashboardScale})`;
                                frameContainer.style.transformOrigin = 'top left';
                                
                                // Set wrapper dimensions
                                const scaledHeight = naturalHeight * dashboardScale;
                                const scaledWidth = naturalWidth * dashboardScale;
                                
                                wrapperDiv.style.width = scaledWidth + 'px';
                                wrapperDiv.style.height = scaledHeight + 'px';
                                wrapperDiv.style.overflow = 'hidden';
                                
                                // Always center the wrapper
                                wrapperDiv.style.margin = '0 auto';
                                wrapperDiv.style.display = 'block';
                                
                                terminalDisplay.style.minHeight = (scaledHeight + padding) + 'px';
                                terminalDisplay.scrollTop = 0;
                            });
                        } else if (dashboardScale) {
                            // Lock frame to its natural size first
                            const naturalWidth = frameContainer.scrollWidth;
                            const naturalHeight = frameContainer.scrollHeight;
                            
                            frameContainer.style.width = naturalWidth + 'px';
                            frameContainer.style.height = naturalHeight + 'px';
                            frameContainer.style.maxWidth = naturalWidth + 'px';
                            frameContainer.style.overflow = 'hidden';
                            
                            // Apply previously calculated scale
                            frameContainer.style.transform = `scale(${dashboardScale})`;
                            frameContainer.style.transformOrigin = 'top left';
                            
                            // Set wrapper dimensions for existing scale
                            const scaledHeight = naturalHeight * dashboardScale;
                            const scaledWidth = naturalWidth * dashboardScale;
                            
                            wrapperDiv.style.width = scaledWidth + 'px';
                            wrapperDiv.style.height = scaledHeight + 'px';
                            wrapperDiv.style.overflow = 'hidden';
                            
                            terminalDisplay.style.minHeight = (scaledHeight + 20) + 'px';
                        }
                    }
                });
                
                terminalSocket.on('terminal_init', (data) => {
                    if (data.lines) {
                        terminalDisplay.innerHTML = '';
                        data.lines.forEach(line => {
                            appendTerminalOutput(line);
                        });
                    }
                });
                
                terminalSocket.on('capture_started', (data) => {
                    if (data.status === 'connected_to_existing') {
                        terminalDisplay.innerHTML = ''; // Clear initial message
                    } else if (data.status === 'no_dashboard_found') {
                        appendTerminalOutput('No active dashboard found. Start training to see dashboard output.');
                    }
                });
                
                terminalSocket.on('capture_stopped', () => {
                    appendTerminalOutput('Dashboard connection stopped.');
                });
            }
            
            function appendTerminalOutput(text) {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'terminal-line';
                lineDiv.textContent = text;
                terminalDisplay.appendChild(lineDiv);
                
                // Limit the number of lines
                while (terminalDisplay.children.length > 1000) {
                    terminalDisplay.removeChild(terminalDisplay.firstChild);
                }
                
                // Scroll to bottom
                terminalDisplay.scrollTop = terminalDisplay.scrollHeight;
            }
            
            function startTerminalCapture() {
                if (terminalSocket && terminalConnected) {
                    // Connect to existing dashboard, don't spawn new process
                    terminalSocket.emit('start_capture', {
                        command: 'connect_existing'
                    });
                }
            }
            
            
            // Load spec data
            let specLoaded = false;
            async function loadSpec() {
                if (specLoaded) return;
                
                const container = document.getElementById('spec-container');
                
                try {
                    const response = await fetch(`${API_BASE_URL}/api/spec`);
                    if (!response.ok) throw new Error('Failed to fetch spec');
                    
                    const data = await response.json();
                    specLoaded = true;
                    
                    let html = '';
                    
                    // Identity section with hashes (moved to top)
                    if (data.full_hash && data.truncated_hash) {
                        html += '<div class="spec-section">';
                        html += '<div class="spec-title">Hashes</div>';
                        
                        const truncLen = data.truncated_hash.length;
                        const truncPart = data.full_hash.substring(0, truncLen);
                        const restPart = data.full_hash.substring(truncLen);
                        html += '<div class="spec-hash">';
                        html += `<span style="color: #4caf50; font-weight: 600;">${truncPart}</span>`;
                        html += `<span style="color: var(--text);">${restPart}</span>`;
                        html += '</div>';
                        html += '</div>';
                    }
                    
                    // Checkout section with git clone URL
                    if (data.git_url) {
                        html += '<div class="spec-section">';
                        html += '<div class="spec-title">Checkout</div>';
                        html += '<div class="spec-code-block">';
                        html += `<code>git clone ${data.git_url}</code>`;
                        html += '</div>';
                        html += '</div>';
                    }
                    
                    // Parameter statistics (using only green and white)
                    if (data.param_stats) {
                        html += '<div class="spec-section">';
                        html += '<div class="spec-title">Parameter Statistics</div>';
                        
                        if (data.param_stats.total_params) {
                            html += `<div class="spec-metadata">Model Parameters: <span style="color: #4caf50; font-weight: 600;">${data.param_stats.total_params.toLocaleString()}</span></div>`;
                        }
                        
                        if (data.param_stats.activation_params) {
                            const config = data.param_stats.config || {};
                            html += `<div class="spec-metadata">Activation Estimate: <span style="color: #4caf50; font-weight: 600;">${data.param_stats.activation_params.toLocaleString()}</span>`;
                            if (config.batch_size || config.block_size || config.hidden_size || config.depth) {
                                html += ` <span style="color: var(--light-text); font-size: 12px;">(batch=${config.batch_size || '?'}, seq=${config.block_size || '?'}, hidden=${config.hidden_size || '?'}, depth=${config.depth || '?'}, experts=${config.num_experts || '?'})</span>`;
                            }
                            html += '</div>';
                        }
                        
                        if (data.param_stats.total_params && data.param_stats.activation_params) {
                            const totalActive = data.param_stats.total_params + data.param_stats.activation_params;
                            html += `<div class="spec-metadata" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border);">`;
                            html += `Total Active Parameters: <span style="color: #4caf50; font-weight: 600; font-size: 16px;">${totalActive.toLocaleString()}</span>`;
                            html += '</div>';
                        }
                        
                        html += '</div>';
                    }
                    
                    // Model architecture section (renamed to "Specification")
                    if (data.model_architecture) {
                        html += '<div class="spec-section">';
                        html += '<div class="spec-title">Specification</div>';
                        html += `<pre class="spec-code">${data.model_architecture}</pre>`;
                        html += '</div>';
                    }
                    
                    // Command section (merged CLI args and command info)
                    if (data.args || data.command || data.timestamp) {
                        html += '<div class="spec-section">';
                        html += '<div class="spec-title">Command</div>';
                        
                        // Add timestamp first
                        if (data.timestamp) {
                            html += `<div class="spec-metadata">Created: ${data.timestamp}</div>`;
                        }
                        
                        // Add command line
                        if (data.command) {
                            html += `<div class="spec-metadata"><code style="background: #f5f5f5; color: #333; padding: 2px 4px; border-radius: 3px; font-family: 'Cascadia Code', 'Fira Code', monospace;">${data.command}</code></div>`;
                        }

                        // Add CLI arguments as JSON
                        if (data.args) {
                            html += `<pre class="spec-code">${JSON.stringify(data.args, null, 2)}</pre>`;
                        }
                        
                        html += '</div>';
                    }
                    
                    container.innerHTML = html;
                    
                } catch (error) {
                    console.error('Error loading spec:', error);
                    container.innerHTML = '<div style="padding: 20px; color: var(--light-text);">Error loading model specification</div>';
                }
            }
            
            // Tab event listeners
            chatTab.addEventListener('click', () => switchTab('chat'));
            terminalTab.addEventListener('click', () => switchTab('terminal'));
            specTab.addEventListener('click', () => switchTab('spec'));
            
            // Initialize
            loadSettings();
        });
    </script>
</body>
</html>