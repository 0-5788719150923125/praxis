<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tesla Pyramid Logo</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a; /* Dark background to see the effect - you can remove this */
            display: flex;
            align-items: flex-start;
        }

        #tesla-pyramid {
            width: 150px;
            height: 150px;
            position: relative;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="tesla-pyramid">
        <canvas id="canvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // High-DPI canvas setup for zoom resistance
        const dpr = window.devicePixelRatio || 1;
        const displaySize = 300; // Display size in CSS pixels

        // Set actual size in memory (scaled up for retina displays)
        canvas.width = displaySize * dpr;
        canvas.height = displaySize * dpr;

        // Scale the context to ensure correct drawing operations
        ctx.scale(dpr, dpr);

        // Set display size (CSS pixels)
        canvas.style.width = displaySize + 'px';
        canvas.style.height = displaySize + 'px';

        // Use displaySize for all drawing coordinates
        const centerX = displaySize / 2;
        const centerY = displaySize / 2;
        const maxRadius = displaySize * 0.42;

        // 3D rotation angles - GLOBAL for proper pyramid rotation
        let globalRotX = 0;
        let globalRotY = 0;
        let globalRotZ = 0;
        let time = 0;

        // Rotation velocities for full 3D rotation
        let rotVelX = 0.003 + Math.random() * 0.002;
        let rotVelY = 0.005 + Math.random() * 0.002;
        let rotVelZ = 0.002 + Math.random() * 0.001;

        // Morphing parameters for gentle tetrahedron distortion
        let morphPhase = 0;
        let morphSpeed = 0.01;

        // Wind system for directional surges
        let windState = {
            direction: { x: 0, y: 0, z: 0 },
            strength: 0,
            gustTime: 0,
            gustDuration: 0,
            targetDirection: { x: 0, y: 0, z: 0 },
            currentDirection: { x: 0, y: 0, z: 0 }
        };

        function updateWind(time) {
            // Random gusts every few seconds
            if (time - windState.gustTime > windState.gustDuration) {
                // New gust
                windState.gustTime = time;
                windState.gustDuration = 2 + Math.random() * 3; // 2-5 seconds

                // Random direction (favoring horizontal for dandelion effect)
                const angle = Math.random() * Math.PI * 2;
                windState.targetDirection = {
                    x: Math.cos(angle),
                    y: (Math.random() - 0.5) * 0.2, // less vertical movement
                    z: Math.sin(angle)
                };
                windState.strength = 0.3 + Math.random() * 0.7;
            }

            // Smooth transition between wind directions
            const transitionSpeed = 0.05;
            windState.currentDirection.x += (windState.targetDirection.x - windState.currentDirection.x) * transitionSpeed;
            windState.currentDirection.y += (windState.targetDirection.y - windState.currentDirection.y) * transitionSpeed;
            windState.currentDirection.z += (windState.targetDirection.z - windState.currentDirection.z) * transitionSpeed;

            // Fade in/out wind strength
            const gustProgress = (time - windState.gustTime) / windState.gustDuration;
            const envelope = Math.sin(gustProgress * Math.PI); // smooth in/out

            return {
                x: windState.currentDirection.x * windState.strength * envelope,
                y: windState.currentDirection.y * windState.strength * envelope,
                z: windState.currentDirection.z * windState.strength * envelope,
                strength: windState.strength * envelope
            };
        }

        // Tendril class for each electric beam
        class Tendril {
            constructor(index) {
                this.index = index;
                this.reset();
            }

            reset() {
                // Origin at the true center of the tetrahedron (0, 0, 0)
                this.origin = {x: 0, y: 0, z: 0};

                // 25% chance to target edges/vertices for better tetrahedron definition (reduced for performance)
                if (Math.random() < 0.25) {
                    // Target tetrahedron vertices and edges (centered at origin)
                    const targets = [
                        // Base triangle corners (centered tetrahedron)
                        {x: 0, y: 0.5, z: -0.577},      // back vertex
                        {x: -0.5, y: 0.5, z: 0.289},     // left vertex
                        {x: 0.5, y: 0.5, z: 0.289},      // right vertex
                        // Apex
                        {x: 0, y: -0.5, z: 0},
                        // Edge midpoints for better edge coverage
                        {x: -0.25, y: 0.5, z: -0.144},   // back-left edge
                        {x: 0.25, y: 0.5, z: -0.144},    // back-right edge
                        {x: 0, y: 0.5, z: 0.289},        // left-right edge
                        {x: 0, y: 0, z: -0.289},         // apex edges
                        {x: -0.25, y: 0, z: 0.144},
                        {x: 0.25, y: 0, z: 0.144}
                    ];

                    const target = targets[Math.floor(Math.random() * targets.length)];

                    // Add some noise to avoid perfect lines
                    this.baseDirection = {
                        x: target.x + (Math.random() - 0.5) * 0.3,
                        y: target.y + (Math.random() - 0.5) * 0.3,
                        z: target.z + (Math.random() - 0.5) * 0.3
                    };
                } else {
                    // Generate random 3D direction for organic look
                    const phi = Math.random() * Math.PI * 2; // Azimuth
                    const theta = (Math.random() - 0.5) * Math.PI; // Full sphere coverage

                    this.baseDirection = {
                        x: Math.cos(theta) * Math.cos(phi),
                        y: Math.sin(theta),
                        z: Math.cos(theta) * Math.sin(phi)
                    };
                }

                // Normalize direction
                const mag = Math.sqrt(
                    this.baseDirection.x ** 2 +
                    this.baseDirection.y ** 2 +
                    this.baseDirection.z ** 2
                );
                this.baseDirection.x /= mag;
                this.baseDirection.y /= mag;
                this.baseDirection.z /= mag;

                this.lifetime = 0;
                this.maxLifetime = 30 + Math.random() * 40; // Even shorter lifetimes for better performance
                this.opacity = 0;
                this.growing = true;
                this.thickness = 0.5 + Math.random() * 1.5; // Thinner for mass spawns
                this.waveSpeed = 0.02 + Math.random() * 0.02;
                this.waveAmount = 0.02 + Math.random() * 0.02;
                this.color = this.generateColor();
                this.phaseOffset = Math.random() * Math.PI * 2;
                this.lengthProgress = 0;
                this.state = 'growing';
                this.escapeWorldAnchor = null;
                this.willEscape = Math.random() < 0.3; // 30% chance of escaping
            }

            generateColor() {
                const colors = [
                    { r: 138, g: 43, b: 226 },  // Blue violet
                    { r: 147, g: 112, b: 219 }, // Medium purple
                    { r: 123, g: 104, b: 238 }, // Medium slate blue
                    { r: 186, g: 85, b: 211 },  // Medium orchid
                    { r: 255, g: 182, b: 193 }, // Light pink
                    { r: 180, g: 140, b: 255 }, // Light purple
                    { r: 200, g: 162, b: 255 }, // Lighter purple
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            // Detect proximity to pyramid edges for enhanced glow
            detectEdgeProximity(point3D) {
                // Calculate distance to pyramid boundaries
                const yNorm = point3D.y;
                const maxExtent = (yNorm + 1) / 2; // pyramid width at this height

                // Distance to nearest edge in x and z directions
                const xEdgeDist = maxExtent - Math.abs(point3D.x);
                const zEdgeDist = maxExtent - Math.abs(point3D.z);
                const minEdgeDist = Math.min(xEdgeDist, zEdgeDist);

                // Also check distance to apex edges
                const distToApex = Math.sqrt(point3D.x * point3D.x + point3D.z * point3D.z);
                const apexEdgeDist = Math.abs(distToApex - Math.abs(yNorm + 1) * 0.5);

                const finalDist = Math.min(minEdgeDist, apexEdgeDist);

                return {
                    distance: finalDist,
                    isNearEdge: finalDist < 0.15, // threshold for "near edge"
                    glowIntensity: Math.max(0, 1 - finalDist / 0.15)
                };
            }

            // Rotate a 3D point
            rotate3D(point, rotX, rotY, rotZ) {
                let { x, y, z } = point;

                // Rotate around X axis
                const cosX = Math.cos(rotX);
                const sinX = Math.sin(rotX);
                const y1 = y * cosX - z * sinX;
                const z1 = y * sinX + z * cosX;
                y = y1;
                z = z1;

                // Rotate around Y axis
                const cosY = Math.cos(rotY);
                const sinY = Math.sin(rotY);
                const x1 = x * cosY + z * sinY;
                const z2 = -x * sinY + z * cosY;
                x = x1;
                z = z2;

                // Rotate around Z axis
                const cosZ = Math.cos(rotZ);
                const sinZ = Math.sin(rotZ);
                const x2 = x * cosZ - y * sinZ;
                const y2 = x * sinZ + y * cosZ;

                return { x: x2, y: y2, z: z2 };
            }

            unrotate3D(point, rotX, rotY, rotZ) {
                let { x, y, z } = point;

                // Reverse Z-axis rotation
                let cos = Math.cos(-rotZ);
                let sin = Math.sin(-rotZ);
                let tempX = x * cos - y * sin;
                let tempY = x * sin + y * cos;
                x = tempX;
                y = tempY;

                // Reverse Y-axis rotation
                cos = Math.cos(-rotY);
                sin = Math.sin(-rotY);
                tempX = x * cos + z * sin;
                let tempZ = -x * sin + z * cos;
                x = tempX;
                z = tempZ;

                // Reverse X-axis rotation
                cos = Math.cos(-rotX);
                sin = Math.sin(-rotX);
                tempY = y * cos - z * sin;
                tempZ = y * sin + z * cos;
                y = tempY;
                z = tempZ;

                return { x, y, z };
            }

            // Ray-tetrahedron intersection in LOCAL space (before rotation)
            findPyramidIntersection(direction) {
                // Cache the result for this direction
                if (this.cachedIntersection &&
                    this.cachedDirection === direction) {
                    return this.cachedIntersection;
                }

                let maxT = 0.8; // Reduced max distance to keep tendrils more contained

                // More accurate intersection test with tighter bounds
                for (let t = 0.02; t <= 1.5; t += 0.03) { // Slightly finer steps
                    const point = {
                        x: this.origin.x + direction.x * t,
                        y: this.origin.y + direction.y * t,
                        z: this.origin.z + direction.z * t
                    };

                    // Stricter tetrahedron bounds check
                    if (point.y < -0.48 || point.y > 0.48) { // Slightly tighter bounds
                        maxT = Math.min(maxT, t * 0.9); // Scale down to keep inside
                        break;
                    }

                    // More accurate triangular base check
                    const height = (point.y + 0.5); // 0 at apex, 1 at base
                    if (height > 0.01) { // Small epsilon to avoid division issues
                        const scale = height * 0.95; // Slightly smaller scale for better containment
                        const scaledX = point.x / scale;
                        const scaledZ = point.z / scale;

                        // Tighter triangular boundary for better containment
                        if (scaledZ < -0.55 || scaledZ > 0.27 ||
                            Math.abs(scaledX) > 0.48) {
                            maxT = Math.min(maxT, t * 0.85); // Further reduce to stay inside
                            break;
                        }
                    }
                }

                // Cache the result
                this.cachedDirection = direction;
                this.cachedIntersection = Math.min(maxT, 0.8);
                return this.cachedIntersection;
            }

            update() {
                this.lifetime++;

                // Grow the tendril quickly
                if (this.lengthProgress < 1) {
                    this.lengthProgress = Math.min(1, this.lengthProgress + 0.1);
                }

                // Faster fade in/out for mass spawns
                if (this.growing) {
                    this.opacity = Math.min(0.6, this.opacity + 0.05);
                    if (this.lifetime > this.maxLifetime * 0.6) {
                        this.growing = false;
                    }
                } else {
                    this.opacity = Math.max(0, this.opacity - 0.03);
                    if (this.opacity <= 0) {
                        this.reset();
                    }
                }
            }

            draw() {
                // Find intersection with pyramid in LOCAL space
                const maxLength = this.findPyramidIntersection(this.baseDirection);

                // AT ESCAPE: Capture anchor point
                if (this.state === 'growing' && this.lengthProgress >= 1 && this.willEscape) {
                    this.state = 'escaped';
                    const localTip = {
                        x: this.origin.x + this.baseDirection.x * maxLength,
                        y: this.origin.y + this.baseDirection.y * maxLength,
                        z: this.origin.z + this.baseDirection.z * maxLength
                    };
                    // The crucial step: transform to world space and store it
                    this.escapeWorldAnchor = this.rotate3D(localTip, globalRotX, globalRotY, globalRotZ);
                }

                // Generate the tendril path
                const segments = [];
                const segmentCount = 15; // Reduced for better performance
                let maxEdgeGlow = 0; // Track maximum edge proximity for this tendril

                let pathDirection = this.baseDirection;
                let pathLength = maxLength * this.lengthProgress;

                if (this.state === 'escaped' && this.escapeWorldAnchor) {
                    const localAnchor = this.unrotate3D(this.escapeWorldAnchor, globalRotX, globalRotY, globalRotZ);
                    const dirToAnchor = {
                        x: localAnchor.x - this.origin.x,
                        y: localAnchor.y - this.origin.y,
                        z: localAnchor.z - this.origin.z
                    };
                    const mag = Math.sqrt(dirToAnchor.x ** 2 + dirToAnchor.y ** 2 + dirToAnchor.z ** 2);
                    if (mag > 0) {
                        pathDirection = { x: dirToAnchor.x / mag, y: dirToAnchor.y / mag, z: dirToAnchor.z / mag };
                    }
                    pathLength = mag;
                }


                for (let i = 0; i <= segmentCount; i++) {
                    const t = i / segmentCount;
                    const adjustedT = t;

                    // Add subtle wave motion
                    const wave1 = Math.sin(this.lifetime * this.waveSpeed + t * 5 + this.phaseOffset) * this.waveAmount;
                    const wave2 = Math.cos(this.lifetime * this.waveSpeed * 0.7 + t * 4) * this.waveAmount * 0.7;

                    // Calculate position in LOCAL space (from origin at center)
                    const localPos = {
                        x: this.origin.x + pathDirection.x * adjustedT * pathLength + wave1 * (1 - t * 0.5),
                        y: this.origin.y + pathDirection.y * adjustedT * pathLength + wave2 * (1 - t * 0.5),
                        z: this.origin.z + pathDirection.z * adjustedT * pathLength + wave1 * 0.3 * (1 - t * 0.5)
                    };

                    let edgeGlow = 0;
                    if (this.state !== 'escaped') {
                        // Check edge proximity for enhanced effects
                        const edgeInfo = this.detectEdgeProximity(localPos);
                        maxEdgeGlow = Math.max(maxEdgeGlow, edgeInfo.glowIntensity);
                        edgeGlow = edgeInfo.glowIntensity;
                    }

                    // Apply GLOBAL pyramid rotation
                    const worldPos = this.rotate3D(localPos, globalRotX, globalRotY, globalRotZ);

                    // Project to 2D with perspective
                    const perspective = 2 / (2 - worldPos.z * 0.3);
                    const x2D = centerX + worldPos.x * maxRadius * perspective;
                    const y2D = centerY + worldPos.y * maxRadius * perspective * 0.8;

                    segments.push({
                        x: x2D,
                        y: y2D,
                        z: worldPos.z,
                        t: t,
                        edgeGlow: edgeGlow
                    });
                }

                // Draw the tendril
                if (segments.length < 2) return;

                ctx.beginPath();
                ctx.moveTo(segments[0].x, segments[0].y);

                // Draw smooth curve
                for (let i = 1; i < segments.length - 1; i++) {
                    const xc = (segments[i].x + segments[i + 1].x) / 2;
                    const yc = (segments[i].y + segments[i + 1].y) / 2;
                    ctx.quadraticCurveTo(segments[i].x, segments[i].y, xc, yc);
                }

                const last = segments[segments.length - 1];
                ctx.lineTo(last.x, last.y);

                // Gradient
                const gradient = ctx.createLinearGradient(
                    segments[0].x, segments[0].y,
                    last.x, last.y
                );

                gradient.addColorStop(0, `rgba(255, 255, 255, ${this.opacity * 0.9})`);
                gradient.addColorStop(0.3, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`);
                gradient.addColorStop(0.8, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity * 0.7})`);
                gradient.addColorStop(1, `rgba(255, 255, 255, ${this.opacity * 0.5})`);

                ctx.strokeStyle = gradient;
                ctx.lineWidth = this.thickness * (1 - last.t * 0.3);
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Reduced shadow effects for better performance
                const isSurge = tendrils.length > 50;
                if (isSurge && maxEdgeGlow > 0.5) {
                    // Only apply shadow during significant edge proximity
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity * 0.4})`;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                } else {
                    ctx.stroke();
                }

                // Simplified endpoint spot without shadow
                if (this.lengthProgress > 0.9 && this.thickness > 1 && this.opacity > 0.3) {
                    ctx.beginPath();
                    ctx.arc(last.x, last.y, 1.5, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity * 0.4})`;
                    ctx.fill();
                }
            }
        }

        // Tendril management (reduced for performance)
        const minTendrils = 3;
        const normalTendrils = 12;
        const surgeTendrils = 50;
        const maxTendrils = 400;
        const tendrils = [];

        // Initialize with a few tendrils
        for (let i = 0; i < minTendrils; i++) {
            tendrils.push(new Tendril(i));
        }

        let tendrilIndex = minTendrils;
        let lastSurgeTime = -1000;
        let frameCount = 0;

        // Tetrahedron edge definitions with morphing
        function getPyramidEdges(morphFactor = 0) {
            // Morphing distortion factors
            const morph1 = Math.sin(morphPhase) * morphFactor;
            const morph2 = Math.cos(morphPhase * 1.3) * morphFactor;
            const morph3 = Math.sin(morphPhase * 0.7) * morphFactor;

            // Define tetrahedron vertices (centered at 0,0,0 for proper rotation)
            const vertices = {
                // Base triangle vertices (at y = 0.5)
                b1: {x: 0 + morph1 * 0.1, y: 0.5, z: -0.577 + morph2 * 0.05},      // back vertex
                b2: {x: -0.5 + morph2 * 0.08, y: 0.5, z: 0.289 + morph3 * 0.05},   // left vertex
                b3: {x: 0.5 + morph3 * 0.08, y: 0.5, z: 0.289 + morph1 * 0.05},    // right vertex
                // Apex (at y = -0.5 for centering)
                apex: {x: 0 + morph2 * 0.05, y: -0.5 + morph1 * 0.1, z: 0 + morph3 * 0.05}
            };

            // Define edges (only 6 edges for tetrahedron)
            return [
                // Base edges (3)
                {start: vertices.b1, end: vertices.b2, type: 'base'},
                {start: vertices.b2, end: vertices.b3, type: 'base'},
                {start: vertices.b3, end: vertices.b1, type: 'base'},
                // Apex edges (3)
                {start: vertices.b1, end: vertices.apex, type: 'apex'},
                {start: vertices.b2, end: vertices.apex, type: 'apex'},
                {start: vertices.b3, end: vertices.apex, type: 'apex'}
            ];
        }

        // Optimized edge illumination calculation
        let edgeIlluminationCache = new Map();
        let lastCacheFrame = -1;

        function calculateEdgeIllumination(edge, tendrils, frameCount) {
            // Cache illumination values per frame
            if (frameCount !== lastCacheFrame) {
                edgeIlluminationCache.clear();
                lastCacheFrame = frameCount;
            }

            const cacheKey = `${edge.start.x},${edge.start.y},${edge.start.z}-${edge.end.x},${edge.end.y},${edge.end.z}`;
            if (edgeIlluminationCache.has(cacheKey)) {
                return edgeIlluminationCache.get(cacheKey);
            }

            let illumination = 0;
            const proximityThreshold = 0.4; // Increased for better visibility
            let totalContribution = 0;

            // Sample tendrils for edge illumination
            const skipFactor = tendrils.length > 150 ? 3 : tendrils.length > 75 ? 2 : 1;
            const maxSamples = 50; // Increased for better edge coverage
            let sampledCount = 0;

            for (let idx = 0; idx < tendrils.length && sampledCount < maxSamples; idx += skipFactor) {
                sampledCount++;
                const tendril = tendrils[idx];

                // Skip invisible tendrils
                if (tendril.opacity < 0.1) continue;

                // Simplified proximity check - just check tendril endpoint
                // Use cached intersection if available
                const maxLength = tendril.cachedIntersection || 0.8;
                const endT = tendril.lengthProgress;

                // Check multiple points along tendril for edge proximity
                for (let sample = 0; sample <= 2; sample++) {
                    const t = sample * 0.4 * endT;

                    // Calculate position from tendril origin (default to 0,0,0 if not set)
                    const origin = tendril.origin || {x: 0, y: 0, z: 0};
                    const pos = {
                        x: origin.x + tendril.baseDirection.x * t * maxLength,
                        y: origin.y + tendril.baseDirection.y * t * maxLength,
                        z: origin.z + tendril.baseDirection.z * t * maxLength
                    };

                    // Quick distance check
                    const dist = pointToLineDistanceSquared(pos, edge.start, edge.end);

                    if (dist < proximityThreshold * proximityThreshold) {
                        const actualDist = Math.sqrt(dist);
                        const proximity = 1 - (actualDist / proximityThreshold);
                        totalContribution += proximity * tendril.opacity * 0.5; // Increased contribution
                    }
                }
            }

            illumination = Math.min(1, totalContribution);
            edgeIlluminationCache.set(cacheKey, illumination);
            return illumination;
        }

        // Optimized squared distance calculation (avoids sqrt)
        function pointToLineDistanceSquared(point, lineStart, lineEnd) {
            const line = {
                x: lineEnd.x - lineStart.x,
                y: lineEnd.y - lineStart.y,
                z: lineEnd.z - lineStart.z
            };

            const toPoint = {
                x: point.x - lineStart.x,
                y: point.y - lineStart.y,
                z: point.z - lineStart.z
            };

            const lineLengthSq = line.x * line.x + line.y * line.y + line.z * line.z;
            if (lineLengthSq === 0) return toPoint.x * toPoint.x + toPoint.y * toPoint.y + toPoint.z * toPoint.z;

            const t = Math.max(0, Math.min(1, (toPoint.x * line.x + toPoint.y * line.y + toPoint.z * line.z) / lineLengthSq));

            const closest = {
                x: lineStart.x + t * line.x - point.x,
                y: lineStart.y + t * line.y - point.y,
                z: lineStart.z + t * line.z - point.z
            };

            return closest.x * closest.x + closest.y * closest.y + closest.z * closest.z;
        }

        // Get t parameter for closest point on line
        function getClosestPointOnLineT(point, lineStart, lineEnd) {
            const line = {
                x: lineEnd.x - lineStart.x,
                y: lineEnd.y - lineStart.y,
                z: lineEnd.z - lineStart.z
            };

            const toPoint = {
                x: point.x - lineStart.x,
                y: point.y - lineStart.y,
                z: point.z - lineStart.z
            };

            const lineLengthSq = line.x * line.x + line.y * line.y + line.z * line.z;
            if (lineLengthSq === 0) return 0;

            return Math.max(0, Math.min(1, (toPoint.x * line.x + toPoint.y * line.y + toPoint.z * line.z) / lineLengthSq));
        }

        // Calculate distance from point to line segment
        function pointToLineDistance(point, lineStart, lineEnd) {
            const line = {
                x: lineEnd.x - lineStart.x,
                y: lineEnd.y - lineStart.y,
                z: lineEnd.z - lineStart.z
            };

            const toPoint = {
                x: point.x - lineStart.x,
                y: point.y - lineStart.y,
                z: point.z - lineStart.z
            };

            const lineLengthSq = line.x * line.x + line.y * line.y + line.z * line.z;
            if (lineLengthSq === 0) return Math.sqrt(toPoint.x * toPoint.x + toPoint.y * toPoint.y + toPoint.z * toPoint.z);

            const t = Math.max(0, Math.min(1, (toPoint.x * line.x + toPoint.y * line.y + toPoint.z * line.z) / lineLengthSq));

            const closest = {
                x: lineStart.x + t * line.x,
                y: lineStart.y + t * line.y,
                z: lineStart.z + t * line.z
            };

            const dx = point.x - closest.x;
            const dy = point.y - closest.y;
            const dz = point.z - closest.z;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }

        // Draw pyramid edges with illumination
        function drawPyramidEdges(edges, tendrils, frameCount) {
            ctx.save();

            for (let edge of edges) {
                // Calculate illumination for this edge
                const illumination = calculateEdgeIllumination(edge, tendrils, frameCount);

                // Only draw if there's some illumination
                if (illumination > 0.01) {
                    // Rotate edge vertices
                    const rotatedStart = tendrils[0].rotate3D(edge.start, globalRotX, globalRotY, globalRotZ);
                    const rotatedEnd = tendrils[0].rotate3D(edge.end, globalRotX, globalRotY, globalRotZ);

                    // Project to 2D
                    const perspectiveStart = 2 / (2 - rotatedStart.z * 0.3);
                    const perspectiveEnd = 2 / (2 - rotatedEnd.z * 0.3);

                    const x1 = centerX + rotatedStart.x * maxRadius * perspectiveStart;
                    const y1 = centerY + rotatedStart.y * maxRadius * perspectiveStart * 0.8;
                    const x2 = centerX + rotatedEnd.x * maxRadius * perspectiveEnd;
                    const y2 = centerY + rotatedEnd.y * maxRadius * perspectiveEnd * 0.8;

                    // Draw edge with illumination-based opacity
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);

                    // Create gradient along edge
                    const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
                    const baseOpacity = illumination * 0.6;
                    const glowOpacity = illumination * 0.3;

                    // Edge type affects color
                    if (edge.type === 'apex') {
                        gradient.addColorStop(0, `rgba(147, 112, 219, ${baseOpacity})`);
                        gradient.addColorStop(0.5, `rgba(180, 140, 255, ${baseOpacity * 1.2})`);
                        gradient.addColorStop(1, `rgba(200, 162, 255, ${baseOpacity})`);
                    } else {
                        gradient.addColorStop(0, `rgba(138, 43, 226, ${baseOpacity})`);
                        gradient.addColorStop(0.5, `rgba(147, 112, 219, ${baseOpacity * 1.2})`);
                        gradient.addColorStop(1, `rgba(138, 43, 226, ${baseOpacity})`);
                    }

                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 1 + illumination * 1.5;

                    // Add glow effect
                    ctx.shadowBlur = 5 + illumination * 15;
                    ctx.shadowColor = `rgba(180, 140, 255, ${glowOpacity})`;

                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Clear canvas
            ctx.clearRect(0, 0, displaySize, displaySize);

            // Update time
            time += 0.012;

            // Update full 3D rotation (continuous rotation on all axes)
            globalRotX += rotVelX;
            globalRotY += rotVelY;
            globalRotZ += rotVelZ;

            // Occasionally change rotation velocities for variety
            if (Math.random() < 0.002) {
                rotVelX += (Math.random() - 0.5) * 0.002;
                rotVelY += (Math.random() - 0.5) * 0.002;
                rotVelZ += (Math.random() - 0.5) * 0.001;

                // Keep velocities in reasonable range
                rotVelX = Math.max(-0.01, Math.min(0.01, rotVelX));
                rotVelY = Math.max(-0.01, Math.min(0.01, rotVelY));
                rotVelZ = Math.max(-0.008, Math.min(0.008, rotVelZ));
            }

            // Update morphing phase
            morphPhase += morphSpeed;

            // Calculate spawn intensity with MASSIVE surges
            const baseWave = Math.sin(time * 0.3) * 0.5 + 0.5;
            const mediumWave = Math.sin(time * 0.7 + Math.PI/4) * 0.3 + 0.3;
            const fastWave = Math.sin(time * 1.5 - Math.PI/3) * 0.2 + 0.2;

            // HUGE surge events - rare but massive
            let surgeMultiplier = 1;
            const surgeProbability = Math.sin(time * 0.15); // Slow wave for surge timing

            if (surgeProbability > 0.95 && time - lastSurgeTime > 5) {
                // MASSIVE surge event!
                surgeMultiplier = 20 + Math.random() * 30; // 20x to 50x multiplier
                lastSurgeTime = time;
            } else if (surgeProbability > 0.7) {
                // Medium surge
                surgeMultiplier = 3 + Math.random() * 5;
            }

            const baseIntensity = (baseWave + mediumWave + fastWave) / 3;
            const spawnIntensity = Math.min(1, baseIntensity * surgeMultiplier);

            // Calculate target tendril count
            let targetCount;
            if (surgeMultiplier > 10) {
                // Large surge - spawn moderately
                targetCount = Math.floor(80 + Math.random() * 120);
            } else if (surgeMultiplier > 3) {
                // Medium surge
                targetCount = Math.floor(30 + Math.random() * 30);
            } else {
                // Normal oscillation
                targetCount = Math.floor(minTendrils + (normalTendrils - minTendrils) * baseIntensity);
            }

            // Spawn tendrils aggressively during surges
            if (tendrils.length < targetCount) {
                const spawnRate = surgeMultiplier > 10 ? 8 : 2; // Moderate spawn rate
                for (let i = 0; i < spawnRate && tendrils.length < Math.min(targetCount, maxTendrils); i++) {
                    tendrils.push(new Tendril(tendrilIndex++));
                }
            }

            // Draw central core that responds to surges
            const coreSize = 8 + Math.sin(time * 2) * 1 + Math.min(15, surgeMultiplier);
            const coreGlow = 0.5 + Math.min(0.5, surgeMultiplier * 0.02);

            const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreSize * 1.5);
            coreGradient.addColorStop(0, `rgba(255, 255, 255, ${coreGlow})`);
            coreGradient.addColorStop(0.3, `rgba(220, 200, 255, ${coreGlow * 0.8})`);
            coreGradient.addColorStop(0.6, `rgba(147, 112, 219, ${coreGlow * 0.5})`);
            coreGradient.addColorStop(1, 'rgba(138, 43, 226, 0.05)');

            ctx.beginPath();
            ctx.arc(centerX, centerY, coreSize, 0, Math.PI * 2);
            ctx.fillStyle = coreGradient;
            ctx.fill();

            // Simplified core glow for better performance
            if (surgeMultiplier > 5) {
                ctx.shadowBlur = 25;
                ctx.shadowColor = `rgba(180, 140, 255, 0.5)`;
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            // Get morphed pyramid edges and draw them with proximity-based illumination
            const pyramidEdges = getPyramidEdges(0.15); // 15% morphing strength
            drawPyramidEdges(pyramidEdges, tendrils, frameCount);
            frameCount++;

            // Sort tendrils by z-depth only every few frames for performance
            if (frameCount % 3 === 0) {
                tendrils.sort((a, b) => {
                    // Use cached z-values if available
                    if (!a.sortZ || frameCount !== a.lastSortFrame) {
                        const aRotated = a.rotate3D(a.baseDirection, globalRotX, globalRotY, globalRotZ);
                        a.sortZ = aRotated.z;
                        a.lastSortFrame = frameCount;
                    }
                    if (!b.sortZ || frameCount !== b.lastSortFrame) {
                        const bRotated = b.rotate3D(b.baseDirection, globalRotX, globalRotY, globalRotZ);
                        b.sortZ = bRotated.z;
                        b.lastSortFrame = frameCount;
                    }
                    return a.sortZ - b.sortZ;
                });
            }

            // Update and draw all tendrils
            for (let i = 0; i < tendrils.length; i++) {
                tendrils[i].update();
                tendrils[i].draw();
            }

            // Clean up dead tendrils - aggressive cleanup after surges
            if (surgeMultiplier <= 1 && tendrils.length > targetCount + 10) {
                // Fast cleanup after surge
                const removeCount = Math.min(10, tendrils.length - targetCount);
                for (let i = 0; i < removeCount; i++) {
                    tendrils.shift();
                }
            } else if (tendrils.length > maxTendrils) {
                // Hard limit
                tendrils.splice(0, tendrils.length - maxTendrils);
            }
        }

        animate();
    </script>
</body>
</html>